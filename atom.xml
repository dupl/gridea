<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dupl.github.io/gridea</id>
    <title>Gridea</title>
    <updated>2025-04-15T08:01:49.795Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dupl.github.io/gridea"/>
    <link rel="self" href="https://dupl.github.io/gridea/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://dupl.github.io/gridea/images/avatar.png</logo>
    <icon>https://dupl.github.io/gridea/favicon.ico</icon>
    <rights>All rights reserved 2025, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Future Blog Post]]></title>
        <id>https://dupl.github.io/gridea/post/2199-01-01-future-post/</id>
        <link href="https://dupl.github.io/gridea/post/2199-01-01-future-post/">
        </link>
        <updated>2198-12-31T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>This post will show up by default. To disable scheduling of future posts, edit <code>config.yml</code> and set <code>future: false</code>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个完整的初学者指南Django-part2]]></title>
        <id>https://dupl.github.io/gridea/post/一个完整的初学者指南Django-part2/</id>
        <link href="https://dupl.github.io/gridea/post/一个完整的初学者指南Django-part2/">
        </link>
        <updated>2025-02-20T12:50:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/featured.jpg" alt="一个完整的初学者指南Django  - 第2部分" loading="lazy"></figure>
<p><img src="https://img.shields.io/badge/python-3.6.2-brightgreen.svg" alt="Python 3.6.2" loading="lazy"> <img src="https://img.shields.io/badge/django-1.11.4-brightgreen.svg" alt="Django 1.11.4" loading="lazy"></p>
<h4 id="介绍">介绍</h4>
<p>欢迎来到 Django 教程的第二部分！在上一课中，我们安装了项目所需要的一切软件，希望你们在学习这篇文章之前，安装了 Python 3.6，并且在虚拟环境中运行Django 1.11。因为，在本篇文章中，我们将继续在这个项目中编写我们的代码。</p>
<p>在这一篇文章中，可能不会有太多的代码操作，主要是讨论分析项目。在下一篇中，我们就开始学习 Django 的基础知识，包括模型（models），管理后台（admin），视图（views），模板（templates）和 路由（URL）。</p>
<p>在这里，还是跟第一篇一样，建议大家多动手。</p>
<hr>
<h4 id="论坛项目">论坛项目</h4>
<p>每个人的学习习惯都是不同的，不知道你们是怎样的，就我个人而言，通过看实例和一些代码片段，可以让我学的更多，学的更快。但是，有些时候当我们看到 <code>Class A</code>和<code>Class B</code> ，或者是 <code>foo(bar)</code> 这样的例子的时候，我们是很难理解这些概念的。</p>
<p>所以在我们进入模型（models），创建视图（views） 这些有趣的代码实操之前，我们还是需要花点时间，简单的讨论一下我们将怎样设计，开发这个项目。</p>
<p>但是如果你已经有 web 开发经验的，而且觉得讲的太细了，那么你可以快速的浏览一下，然后进入到 【模型（models）】那一块中。</p>
<p>如果你对 Web 开发并不熟悉，那么我强烈建议你认真阅读下去。这里会介绍 web 应用程序开发的建模和设计，因为对于 web 开发来说，敲代码只是其中的一部分，模型的设计也是很重要的。</p>
<figure data-type="image" tabindex="2"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Rocket_Science.png" alt="火箭科学" loading="lazy"></figure>
<h5 id="用例图">用例图</h5>
<p>我们的项目本身是一个论坛系统，整个项目来说就是维护几个【论坛板块（boards）】 ，然后在每个板块里面，用户可以通过创建【主题（Topic）】并且在主题中讨论。</p>
<p>一般情况下，只有管理员才能创建【论坛板块（boards）】，那么在用户这方面，我们就需要分为普通用户和管理员用户了，而且他们拥有的权限是不同的，管理员用户可以创建 【论坛板块（boards）】，【主题（Topic）】以及讨论回复，而普通用户只能发布【主题（Topic）】以及讨论回复。具体每个用户角色的功能分配如下图：</p>
<blockquote>
<p>图1：Web Board 核心功能的用例图</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/use-case-diagram.png" alt="用例图" loading="lazy"></figure>
<h5 id="类图">类图</h5>
<p>从上面的用例图中，我们可以开始思考我们项目中的<strong>实体类</strong>有哪些了。这些实体是我们要创建的模型，它与我们的 Django 应用非常密切。</p>
<p>如果要实现上面我们说到的论坛，那么我们至少需要以下的几个模型：<strong>Board</strong>，<strong>Topic</strong>，<strong>Post</strong>和<strong>User</strong>。</p>
<ul>
<li><strong>Board</strong> : 版块</li>
<li><strong>Topic</strong> : 主题</li>
<li><strong>Post</strong> : 帖子（用户评论与回复）</li>
<li><strong>User</strong> : 用户</li>
</ul>
<blockquote>
<p>图2：Web Board 类图</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/basic-class-diagram.png" alt="基本类图" loading="lazy"></figure>
<p>上面我们只是说了需要有几个模型，并没有提到模型与模型之间是怎么关联的。</p>
<p>通过上面的图片我们可以知道，主题（Topic）与版块（Board） 之间是有关联的，就好比我们需要知道这个主题（Topic） 是属于哪一个版块的（Board），因此我们需要一个字段，也就是可以通过外键爱关联它们。</p>
<p>同样的，一个帖子（Post） 也是需要确定它是那个主题的，当然，用户和主题（Topic）和帖子（Post） 之间也是有联系的，因为我们需要确认是谁发的帖子，是谁回复评论了内容。</p>
<p>竟然知道了模型之间的联系了，那么我们也必须要考虑这些模型应该存放哪些信息。就目前而言，我们的模型可以设计成这样：</p>
<blockquote>
<p>图3：类（模型）之间关系的类图</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram.png" alt="类图" loading="lazy"></figure>
<p>这个类图强调的是模型之间的关系，当然最后这些线条和箭头都会用字段来进行表示。</p>
<p><strong>Board（版块模型）</strong> ：Board 中有 <strong>name</strong> 和 <strong>description</strong> 这两个字段，name 是唯一的，主要是为了避免两个名称重复。description 则是用于描述把这个版块来用干什么的。</p>
<p><strong>Topic（主题模型）</strong> ：subject 表示主题内容，last_update 用来定义话题的排序，starter 用来识别谁发起的话题，board 用于指定它属于哪个版块</p>
<p><strong>Post（帖子模型）</strong> ： message 字段，用于存储回复的内容，created_at 创建的时间，在排序时候用（最先发表的帖子排最前面），updated_at 更新时间，告诉用户是否更新了内容，同时，还需要有对应的 User 模型的引用，Post 由谁创建的和谁更新的。</p>
<p><strong>User（用户模型）</strong> ：这里有 username ，password，email 和 is_superuser 四个字段。</p>
<p>这里值得注意的是，我们在 Django 应用中，不需要创建 User 用户模型，因为在 Django 的 contrib 中已经内置了 User 模型，我们可以直接拿来使用，就没必要重新创建了。</p>
<p>认真观察的童鞋应该看到了，上面的模型关系图中，模型与模型之间的对应关系有数字 1，0..* 等等的字段，这是代表什么意思呢？</p>
<p>如下图，<code>1</code> 代表一个 Topic 必须与一个  Board 相关联，<code>0..*</code> 代表 Board 下面可能会有多个和 0 个 Topic ，也就是一对多的关系。</p>
<figure data-type="image" tabindex="6"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-board-topic.png" alt="类图板和主题协会" loading="lazy"></figure>
<p>这里也是一样，<code>1</code> 代表一个 Post 只有一个  Topic ，<code>1..*</code> 代表一个 Topic 下面可能会有 1 个和多个个 Post ，也就是说，一个主题最少一个一个帖子。</p>
<figure data-type="image" tabindex="7"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-post.png" alt="类图主题和帖子关联" loading="lazy"></figure>
<p><code>1</code> 代表一个 Topic 有且至于一个  User ，<code>0..*</code> 代表一个 User（用户） 可能拥有多个 Topic ，也可能没有。</p>
<figure data-type="image" tabindex="8"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-user.png" alt="类图主题和用户关联" loading="lazy"></figure>
<p>Post（帖子） 和 User（用户）的关系也是类似，一个 Post 必须有一个 User ，而一个 User 可能没有也可能有多个 Post。这里的 Post ，用户发布了之后是可以进行修改的，也就是更新（updated_by），当然如果又被修改，updated_by 就是为空了。</p>
<p><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-post-user.png" alt="类图邮政和用户协会" loading="lazy">一</p>
<p>当然，如果你觉得上面的图看起来很复杂，那么你也可以不需要强调模型与模型之间的关系，直接强调字段就可以了，如下图：</p>
<blockquote>
<p>图4：强调类（模型）属性（字段）的类图</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-attributes.png" alt="类图属性" loading="lazy"></figure>
<p>其实这种表达图和前面那个显示箭头和线的表达图，要表达的内容是一样的。不过使用这种表达方式可能更符合 Django  Modles API 的设计。</p>
<p>好了，现在已经够 UML 了！为了绘制本节介绍的图表，我使用的是 <a href="http://staruml.io/">StarUML</a> 工具。</p>
<h5 id="原型图">原型图</h5>
<p>花了一些时间来设计我们的程序模型，后面我们也需要设计一下我们的网页原型图。只有这样，才能更好的让我们清楚的知道自己将要干什么？</p>
<figure data-type="image" tabindex="10"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Wireframes.png" alt="线框漫画" loading="lazy"></figure>
<p>首先，是我们的主页，在主页中，我们会显示我们所有的版块：</p>
<blockquote>
<p>图5：主页显示所有的版块信息</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-boards.png" alt="线框板" loading="lazy"></figure>
<p>同样的，当用户点进了版块信息，进入到版块页面，那么版块页面也将显示该版块下的所有主题：</p>
<blockquote>
<p>图6：版块下的所有主题信息</p>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-topics.png" alt="线框主题" loading="lazy"></figure>
<p>通过观察图片，细心的你，可能会发现，用户在这个页面有两条可以走的路线。第一条就是点击 “new topic” 来创建新的主题，第二条就是点击已经存在的主题进入相关的主题进行讨论回复。</p>
<p>“new topic” 的界面如下 ：</p>
<figure data-type="image" tabindex="13"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-new-topic.png" alt="线框新主题" loading="lazy"></figure>
<p>而，进入了相关的主题后，应该显示具体的帖子信息和用户的一些回复信息：</p>
<figure data-type="image" tabindex="14"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-posts.png" alt="线框帖子" loading="lazy"></figure>
<p>如果用户点击 “Reply” 的按钮，他们将看到下面的页面，并以相反的顺序（最新的第一个）对帖子进行显示：</p>
<figure data-type="image" tabindex="15"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-reply.png" alt="线框回复" loading="lazy"></figure>
<p>那么这些图是用什么来绘制的呢？你可以使用 <a href="https://draw.io/">draw.io</a> ，而且他是完全免费的。</p>
<hr>
<h4 id="模型models">模型（Models）</h4>
<p>上一部分，设计了我们 Web 应用的数据库还有界面原型设计。在模型（Models）这一部分中，我们将在 Django 中创建我们数据库的模型类：<strong>Board</strong> ，<strong>Topic</strong> 和 <strong>Post</strong> 。</p>
<p>这里是不是有个疑问，明明我们设计数据库的时候是有 <strong>User</strong> 的，为什么我们不用创建它的模型类呢？是不是写漏了？</p>
<p>并不是，那是因为 <strong>User</strong> 这个模型类，已经内置在 Django 应用程序中的，<strong>User</strong> 模型就在 <strong>django.contrib.auth</strong> 中。在 settings.py 中，<code>INSTALLED_APPS</code> 就配置了<strong>django.contrib.auth</strong>。</p>
<p>好了，现在我们将根据我们上面设计的数据库模型来完成我们项目 <strong>boards</strong> 下的 models.py 文件中的所有操作。</p>
<blockquote>
<p><strong>boards/models.py</strong></p>
</blockquote>
<pre><code class="language-python">from django.db import models
from django.contrib.auth.models import User

class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

class Topic(models.Model):
    subject = models.CharField(max_length=255)
    last_updated = models.DateTimeField(auto_now_add=True)
    board = models.ForeignKey(Board, related_name='topics')
    starter = models.ForeignKey(User, related_name='topics')

class Post(models.Model):
    message = models.TextField(max_length=4000)
    topic = models.ForeignKey(Topic, related_name='posts')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    created_by = models.ForeignKey(User, related_name='posts')
    updated_by = models.ForeignKey(User, null=True, related_name='+')
</code></pre>
<p>可以看到，创建的所有模型类，<strong>Board</strong> ， <strong>Topic</strong> 和 <strong>Post</strong> 都是 <strong>django.db.models.Model</strong> 的子类，它们都将会转化成数据表。而 <strong>django.db.models.Field</strong> 的子类（Django 内置的核心类）的实例都会转化为数据表中的列。</p>
<p>上面可以看到的 <code>CharField</code>，<code>DateTimeField</code> 等，都是 <strong>django.db.models.Field</strong> 的子类，在 Django 项目中都可以直接使用它们。</p>
<p>在这里，我们仅仅使用了 <code>CharField</code>，<code>TextField</code>，<code>DateTimeField</code>，和 <code>ForeignKey</code> 字段来定义我们的模型（Models） 。当然，在 Django 中，不仅仅只是提供了这些字段，还提供了更多，更广泛的选择来代表不同类型的数据，比如还有：<code>IntegerField</code>，<code>BooleanField</code>， <code>DecimalField</code>。我们会根据不同的需求来使用它们。</p>
<p>有些字段是需要参数的，就好比 <code>CharField</code> ，我们都设定了一个 <code>max_length</code> , 设置一个最大长度。当我们设定了这个字段后，就会作用于数据的。</p>
<p>在 <code>Board</code> 模型（Model）中，在 <code>name</code> 字段中，我们也设置了参数 <code>unique=True</code>，顾名思义，这是为了在数据库中，保证该字段的唯一性。</p>
<p>在 <code>Post</code> 模型中，<code>created_at</code> 字段有一个可选参数，<code>auto_now_add</code> 设置为 <code>True</code>。这是为了指明 Django 在创建 <code>Post</code> 对象的时候，<code>created_at</code> 使用的是当前的日期和时间。</p>
<p>创建模型与模型之间关系的其中一种方法就是使用 <code>ForeignKey</code> 字段，使用这个字段，会自动创建模型与模型之间的联系，而且会在数据库中也创建它们的关系。使用 <code>ForeignKey</code> 会有一个参数，来表明他与那个模型之间的联系。 例如：</p>
<p>在 <code>Topic</code> 模型中，<code>models.ForeignKey(Board, related_name='topics')</code>，第一个参数是代表关联的表格（主表），在默认情况下，外键存储的是主表的主键（Primary Key）。第二个参数 <code>related_name</code> 是定义一个名称，用于反向查询的。Django 会自动创建这种反向关系。 虽然 <code>related_name</code> 是可选参数，但是如果我们不为它设置一个名称的，Django 会默认生成名称 <code>(class_name)_set</code> 。例如，在 <code>Board</code> 模型中，<code>Topic</code> 实例将在该 <code>topic_set</code> 属性下可用。而我们只是将其重新命名为<code>topics</code>，使用起来更加自然。</p>
<p>在 <code>Post</code> 模型中，<code>updated_by</code> 字段设置<code>related_name='+'</code>。这指示 Django 我们不需要这种反向关系。</p>
<p>下面这张图可以很好地看到设计图和源码之间的比较，其中绿线就表示了我们是如何处理反向关系的。</p>
<figure data-type="image" tabindex="16"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-django-models.png" alt="类图模型定义" loading="lazy"></figure>
<p>可能到这一步，你会问：“主键呢？”好像我们都没有定义主键啊。对，如果我们没有为模型（Models）指定主键，那么 Django 会自动生成它。</p>
<h5 id="迁移模型migrating-the-models">迁移模型（Migrating the Models）</h5>
<p>到这一步，我们要开始告诉 Django 如何创建数据库，这样方便我们更好的使用。</p>
<p>打开<strong>终端</strong> ，激活虚拟环境，进入到 <strong>manage.py</strong> 文件所在的文件夹，然后运行以下命令：</p>
<pre><code>python manage.py makemigrations
</code></pre>
<p>这时，你会看到这样的输出信息：</p>
<pre><code>Migrations for 'boards':
  boards/migrations/0001_initial.py
    - Create model Board
    - Create model Post
    - Create model Topic
    - Add field topic to post
    - Add field updated_by to post
</code></pre>
<p><br>
此时，Django 在 <strong>boards / migrations</strong> 目录内创建了一个名为<strong>0001_initial.py</strong> 的文件。它代表了我们应用程序模型的当前状态。在下一步中，Django 将使用该文件来创建表和列。</p>
<p>迁移文件被翻译成 SQL 语句。如果您熟悉 SQL，则可以运行以下命令来检查将在数据库中执行的 SQL 指令：</p>
<pre><code>python manage.py sqlmigrate boards 0001
</code></pre>
<p>如果你不熟悉 SQL，也不用担心。在本系列教程中，我们不会直接使用 SQL。所有的工作都将使用 Django ORM 来完成，它是一个与数据库进行通信的抽象层。</p>
<p>好了，下一步我们将把我们的迁移文件应用到我们的数据库中：</p>
<pre><code>python manage.py migrate&lt;/code&gt;
</code></pre>
<p>输出应该是这样的：</p>
<pre><code>Operations to perform:
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
</code></pre>
<p>因为这是我们第一次迁移数据库，所以该 <code>migrate</code> 命令还应用了 Django contrib 应用中现有的迁移文件，这些文件列于 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code> 。</p>
<p>而 <code>Applying boards.0001_initial... OK</code> 就是指我们在上一步中生成的迁移文件。</p>
<p>好了，此时！我们的数据库已经可以使用了。</p>
<figure data-type="image" tabindex="17"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_SQLite.png" alt="SQLite的" loading="lazy"></figure>
<blockquote>
<p><strong>注意：</strong> 需要注意的是 <strong>SQLite</strong> 是一个数据库。SQLite 被许多公司用于成千上万的产品，如所有 Android 和 iOS 设备，所有主要的 Web 浏览器，Windows 10，MacOS 等。</p>
<p>当然，它也不是适合所有的应用场景。SQLite 不能与 MySQL，PostgreSQL 或 Oracle 等数据库进行比较。大容量网站，密集型的应用程序，大数据集，高并发性，这些使用使用 SQLite 可能会导致很多问题。</p>
<p>在我们开发的项目中，我们将使用 SQLite ，因为它很方便，我们不需要安装其他任何东西。当我们将项目部署到生产环境时，我们将切换到 PostgreSQL 。因为这对于简单的网站是不错的选择。但这里有一点要注意，对于复杂的网站，建议在开发和生产中使用相同的数据库。</p>
</blockquote>
<h5 id="models-api">Models API</h5>
<p>使用 Python 开发的一个重要优点是交互式 shell。我几乎一直都在使用它。这是一个可以快速尝试和测试实验的方法。</p>
<p>你可以使用 <strong>manage.py</strong> 加载我们的项目来启动 Python shell ：</p>
<p>启动命令：</p>
<pre><code>python manage.py shell
</code></pre>
<p>可以看到这样的输出：</p>
<pre><code>Python 3.6.2 (default, Jul 17 2017, 16:44:45)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
(InteractiveConsole)
&gt;&gt;&gt;
</code></pre>
<p>在我们使用 <code>python manage.py shell</code> 之外，我们也可以将项目添加到<code>sys.path</code>并加载 Django。这意味着我们可以在项目中导入我们的模型(models) 和任何其他资源。</p>
<p>我们从导入 <strong>Board</strong> 类开始：</p>
<pre><code>from boards.models import Board
</code></pre>
<p>如果我们需要创建 <strong>Board</strong> 对象，我们可以执行以下操作：</p>
<pre><code>board = Board(name='Django', description='This is a board about Django.')
</code></pre>
<p>此时我们只是创建了这个对象，并没有保存到数据库的，因此我们可以调用 <code>save</code> 方法，将这个对象保存在数据库中。</p>
<pre><code>board.save()
</code></pre>
<p>该 <code>save</code> 方法 ，在创建对象和更新对象中都可以使用，这里 Django 会创建一个新的对象，因为 <strong>Board</strong> 实例是没有 <strong>id</strong> 这个字段的，因此保存后，Django 会自动设置一个 ID ：</p>
<pre><code>board.id
1
</code></pre>
<p>其他的字段你也可以当作属性来访问就好了，比如：</p>
<pre><code>board.name
'Django'
</code></pre>
<pre><code>board.description
'This is a board about Django.'
</code></pre>
<p>要更新一个值，我们可以这样做：</p>
<pre><code>board.description = 'Django discussion board.'
board.save()
</code></pre>
<p>每个 Django 模型 (Models) 都带有一个特殊的属性; 我们称之为 <strong>Model Manager（模型管理器）</strong>。我们可以通过 Python 属性 <code>objects</code> 来访问它。它主要用于在数据库中执行查询。例如，我们可以使用它来直接创建一个新的<strong>Board</strong> 对象：</p>
<pre><code>board = Board.objects.create(name='Python', description='General discussion about Python.')
</code></pre>
<pre><code>board.id
2
</code></pre>
<pre><code>board.name
'Python'
</code></pre>
<p>所以，结合之前的操作，我们现在有两个 boards 对象。我们可以使用<code>objects</code> 列出数据库中所有现有的 boards ：</p>
<pre><code>Board.objects.all()
&lt;QuerySet [&lt;Board: Board object&gt;, &lt;Board: Board object&gt;]&gt;
</code></pre>
<p>结果是一个 <strong>QuerySet</strong> 。稍后我们会进一步了解它。基本上，它是来自数据库的对象列表。通过输出结果，可以看到我们有两个对象，但我们只能读取 <strong>Board对象</strong> 。这是因为我们没有在 <strong>Board</strong> 模型中定义 <code>__str__</code> 方法。</p>
<p>该 <code>__str__</code> 方法是一个对象的字符串表示。我们可以使用 Board 的名称来表示它。</p>
<p>首先，退出交互式控制台：</p>
<pre><code>exit()
</code></pre>
<p>现在编辑 <strong>boards</strong> 应用程序中的 <strong>models.py</strong> 文件：</p>
<pre><code>class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

    def __str__(self):
        return self.name
</code></pre>
<p>让我们再次尝试查询。再次打开交互式控制台：</p>
<pre><code>from boards.models import Board

Board.objects.all()
&lt;QuerySet [&lt;Board: Django&gt;, &lt;Board: Python&gt;]&gt;
</code></pre>
<p>仔细对比上面的，看下区别？</p>
<p>可以看到上面那个是 object ，而这里是我们定义的字符串。</p>
<p>我们可以将这个 <strong>QuerySet</strong> 看作一个列表。假设我们想遍历它并打印每个 Board（版块） 的描述：</p>
<pre><code>boards_list = Board.objects.all()
for board in boards_list:
    print(board.description)
</code></pre>
<p>结果是：</p>
<pre><code>Django discussion board.
General discussion about Python.
</code></pre>
<p>当然，我们也可以使用 <strong>Model Manager（模型管理器）</strong> 来查询数据库，如果查询其中的一个，我们可以使用 <code>get</code> 的方法：</p>
<pre><code>django_board = Board.objects.get(id=1)

django_board.name
'Django'
</code></pre>
<p>当然我们要小心这种情况，因为很容易发生内存溢出的。比如我们试图去查询一个不存在的对象，就好比我们数据库只有两个 Board 对象，如果你查询 <code>id=3</code>，那么它会引发一个异常：</p>
<pre><code>board = Board.objects.get(id=3)

boards.models.DoesNotExist: Board matching query does not exist.
</code></pre>
<p>当然，在 <code>get</code> 方法中，参数可以是该模型下的字段，最好是使用唯一的标识字段。否则会返回多个对象，会导致异常的。</p>
<pre><code>Board.objects.get(name='Django')
&lt;Board: Django&gt;
</code></pre>
<p>请注意，查询是区分大小写的，小写 “django” 是不匹配的：</p>
<pre><code>Board.objects.get(name='django')
boards.models.DoesNotExist: Board matching query does not exist.
</code></pre>
<h5 id="模型操作摘要">模型操作摘要</h5>
<p>下面的表格是我们在本章节中学到的方法和操作。代码示例使用 <strong>Board</strong> 模型作为参考示例。大写的 <strong>Board</strong> 代表类，小写的 <strong>board</strong> 是指 <strong>Board</strong> 的实例对象。</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>代码示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建一个对象并没有保存</td>
<td><code>board = Board()</code></td>
</tr>
<tr>
<td>保存一个对象（创建或更新）</td>
<td><code>board.save()</code></td>
</tr>
<tr>
<td>在数据库中创建并保存一个对象</td>
<td><code>Board.objects.create(name='...', description='...')</code></td>
</tr>
<tr>
<td>列出所有对象</td>
<td><code>Board.objects.all()</code></td>
</tr>
<tr>
<td>获取由字段标识的单个对象</td>
<td><code>Board.objects.get(id=1)</code></td>
</tr>
</tbody>
</table>
<p>在下一节中，我们将开始编写视图并在 HTML 页面中显示我们的版块页面。</p>
<hr>
<h4 id="views-templates-和静态文件">Views, Templates 和静态文件</h4>
<p>回顾一下，我们之前做的。我们已经可以在应用程序的主页上显示 ”Hello ，World！“ 的界面了。</p>
<blockquote>
<p><strong>MyProject/urls.py</strong></p>
</blockquote>
<pre><code>from django.conf.urls import url
from django.contrib import admin

from boards import views

urlpatterns = [
    url(r'^/code&gt;, views.home, name='home'),
    url(r'^admin/', admin.site.urls),
]
</code></pre>
<blockquote>
<p><strong>boards/views.py</strong></p>
</blockquote>
<pre><code>from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello, World!')
</code></pre>
<p>好了，现在我们需要修改这个主页，如果你不记得我们的主页要做成什么样子，可以看看之前我们已经设计好的原型界面图。我们在主页上，要做的是在表格中显示一些版块的名单和其他的一些信息。</p>
<p>首先我们要做的是：导入 <strong>Board</strong> 模型，然后获取所有的存在的版块（boards）信息</p>
<blockquote>
<p><strong>boards/views.py</strong></p>
</blockquote>
<pre><code>from django.http import HttpResponse
from .models import Board

def home(request):
    boards = Board.objects.all()
    boards_names = list()

    for board in boards:
        boards_names.append(board.name)

    response_html = '&lt;br&gt;'.join(boards_names)

    return HttpResponse(response_html)
</code></pre>
<p>然后我们运行，就会看到这个简单的 HTML 页面：</p>
<figure data-type="image" tabindex="18"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-httpresponse.png" alt="主页HttpResponse" loading="lazy"></figure>
<p>但是，一般情况下，我们是不会通过这种方式去渲染 HTML ，在 <strong>views.py</strong> 中，我们只需要获取 <strong>boards</strong> 的集合，至于 HTML 渲染那部分的代码，我们应该在 Django 的 templates 目录下完成。</p>
<h5 id="django-模板引擎设置">Django 模板引擎设置</h5>
<p>竟然我们要将 <strong>views.py</strong> 里渲染 HTML 的代码分离，那么我们首先要在 <strong>baords</strong> 的同目录下，创建一个名为 <strong>templates</strong> 的文件夹。</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/   &lt;-- here!
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>在我们创建的 <strong>templates</strong> 文件夹中，我们创建一个名为 <strong>home.html</strong> 的 HTML 文件</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Boards&lt;/h1&gt;

    {% for board in boards %}
      {{ board.name }} &lt;br&gt;
    {% endfor %}

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>home.html</strong> 的文件内容如上面的一样，是一些原始的 HTML 标签代码和 Django 语言上的代码：<code>{% for ... in ... %}</code> ，<code>{{ variable }}</code>。上面的代码中展示了如何使用 for 循环遍历 list 对象。</p>
<p>到此，我们的 HTML 页面已经完成了，可是我们还没有告诉 Django 在哪里能找到我们应用中的 <code>templates</code> 文件夹里的 HTML。</p>
<p>首先，我们在 Django 中绑定一下我们的 <code>templates</code> ,打开我们 ** myproject** 项目中的 <strong>settings.py</strong> 文件，搜索 <code>TEMPLATES</code> 变量然后在 <code>DIRS</code>设置 ：<code>os.path.join(BASE_DIR, 'templates')</code></p>
<p>具体如下：</p>
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates')
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre>
<p>这样设计就好比相当于在你的项目中的完整路径下，在加上 &quot;/templates&quot;</p>
<p>那是不是跟我们预想的一样呢？我们可以通过 python shell 进行调试：</p>
<pre><code>python manage.py shell
</code></pre>
<pre><code>from django.conf import settings

settings.BASE_DIR
'/Users/vitorfs/Development/myproject'

import os

os.path.join(settings.BASE_DIR, 'templates')
'/Users/vitorfs/Development/myproject/templates'
</code></pre>
<p>可以看到，目录就是指向我们在上面创建的 <strong>templates</strong> 文件夹</p>
<p>此时，我们只是绑定了 <strong>templates</strong> 文件夹的路径，Django 并没有绑定我们 <strong>home.html</strong> ，我们可以在 <strong>views.py</strong> 中绑定：</p>
<pre><code>from django.shortcuts import render
from .models import Board

def home(request):
    boards = Board.objects.all()
    return render(request, 'home.html', {'boards': boards})
</code></pre>
<p>运行后，HTML 的页面是这样的：</p>
<figure data-type="image" tabindex="19"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render.png" alt="主板渲染" loading="lazy"></figure>
<p>我们可以改进HTML模板来代替使用表格：</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Boards&lt;/h1&gt;

    &lt;table border=&quot;1&quot;&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Board&lt;/th&gt;
          &lt;th&gt;Posts&lt;/th&gt;
          &lt;th&gt;Topics&lt;/th&gt;
          &lt;th&gt;Last Post&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {% for board in boards %}
          &lt;tr&gt;
            &lt;td&gt;
              {{ board.name }}&lt;br&gt;
              &lt;small style=&quot;color: #888&quot;&gt;{{ board.description }}&lt;/small&gt;
            &lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
          &lt;/tr&gt;
        {% endfor %}
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render-2.png" alt="主板渲染" loading="lazy"></figure>
<h5 id="测试主页">测试主页</h5>
<figure data-type="image" tabindex="21"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Testing.png" alt="测试漫画" loading="lazy"></figure>
<p>测试这部分会在这系列教程中会不断的重复探讨。</p>
<p>现在让我们来写第一个测试，首先在应用程序 <strong>boards</strong> 中找到 <strong>tests.py</strong></p>
<blockquote>
<p><strong>boards/tests.py</strong></p>
</blockquote>
<pre><code>from django.core.urlresolvers import reverse
from django.test import TestCase

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
</code></pre>
<p>这是一个非常简单的测试用例，但非常的有用。我们在测试的是响应状态码，如果是 200 意味着成功。</p>
<p>我们可以在控制台中检查响应码：</p>
<figure data-type="image" tabindex="22"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/test-homepage-view-status-code-200.png" alt="回应200" loading="lazy"></figure>
<p>如果出现未捕获的异常，语法错误或其他任何情况，Django 会返回状态代码<strong>500</strong>，这意味着<strong>服务器错误</strong>。现在，想象我们的应用程序有 100 个界面（view）。如果我们为所有视图（view）编写了这个简单的测试，只需一个命令，我们就可以测试所有视图是否返回成功代码，这样用户就不会在任何地方看到任何错误消息。如果没有自动化测试，我们需要逐一检查每个页面。</p>
<p>要执行 Django 的测试套件：</p>
<pre><code>python manage.py test
</code></pre>
<pre><code>Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.041s

OK
Destroying test database for alias 'default'...
</code></pre>
<p>现在我们可以测试 Django 是否为请求的 URL 返回了正确的视图函数。这也是一个有用的测试，因为随着开发的进展，您会发现 <strong>urls.py</strong> 模块可能变得非常庞大而复杂。URL 配置全部是关于解析正则表达式的。有些情况下我们有一个非常宽容的URL，所以 Django 最终可能返回错误的视图函数。</p>
<p>以下是我们如何做到的：</p>
<blockquote>
<p><strong>boards/tests.py</strong></p>
</blockquote>
<pre><code>from django.core.urlresolvers import reverse
from django.urls import resolve
from django.test import TestCase
from .views import home

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

    def test_home_url_resolves_home_view(self):
        view = resolve('/')
        self.assertEquals(view.func, home)
</code></pre>
<p>在第二个测试中，我们正在使用 <code>resolve</code> 功能。Django 使用它来将请求的 URL与 <strong>urls.py</strong> 模块中列出的 URL 列表进行匹配。该测试将确保使用 <code>/</code>根 URL ，是否返回主视图（home view）。</p>
<p>再次测试：</p>
<pre><code>python manage.py test
</code></pre>
<pre><code>Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.027s

OK
Destroying test database for alias 'default'...
</code></pre>
<p>要查看有关测试执行的更多详细信息，请将 <strong>verbosity</strong> 设置为更高级别：</p>
<pre><code>python manage.py test --verbosity=2
</code></pre>
<pre><code>Creating test database for alias 'default' ('file:memorydb_default?mode=memory&amp;cache=shared')...
Operations to perform:
  Synchronize unmigrated apps: messages, staticfiles
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
System check identified no issues (0 silenced).
test_home_url_resolves_home_view (boards.tests.HomeTests) ... ok
test_home_view_status_code (boards.tests.HomeTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.017s

OK
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&amp;cache=shared')...
</code></pre>
<p>详细程度决定了将要打印到控制台的通知和调试信息量; 0 是无输出，1 是正常输出，2 是详细输出。</p>
<h5 id="静态文件设置">静态文件设置</h5>
<p>静态文件是指 CSS，JavaScript，字体，图像或者是我们用来组成用户界面的任何其他资源。</p>
<p>事实上，Django 不提供这些文件。但在开发过程中，我们又会用到，因此 Django 提供了一些功能来帮助我们管理静态文件。这些功能可在配置文件（settings.py）中 <code>INSTALLED_APPS</code> 里的 <strong>django.contrib.staticfiles</strong> 。</p>
<p>有了这么多的前端组件库，我们没有理由继续渲染基本的 HTML 。我们可以轻松地将Bootstrap 4 添加到我们的项目中。Bootstrap 是一个用 HTML，CSS 和JavaScript 开发的开源工具包。</p>
<p>在项目根目录中，除<strong>boards</strong>，<strong>templates</strong> 和 <strong>myproject</strong> 文件夹外，我们还需要创建一个名为 <strong>static</strong> 的文件夹，并在 <strong>static</strong> 文件夹内创建另一个名为 <strong>css</strong> 文件夹：</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/       &lt;-- here
 |    |    +-- css/     &lt;-- and here
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>到 <a href="https://getbootstrap.com/docs/4.0/getting-started/download/#compiled-css-and-js">getbootstrap.com</a> 下载最新版本：</p>
<figure data-type="image" tabindex="23"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/bootstrap-download.png" alt="Bootstrap下载" loading="lazy"></figure>
<p>下载 <strong>Compiled CSS and JS</strong> 的版本。</p>
<p>解压从 Bootstrap 网站下载的 <strong>bootstrap-4.0.0-beta-dist.zip</strong> 文件，将文件 <strong>css / bootstrap.min.css</strong> 复制到我们项目的css文件夹中：</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/
 |    |    +-- css/
 |    |         +-- bootstrap.min.css    &lt;-- here
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>还是一样的问题，我们需要将 Django 中的 <strong>settings.py</strong> 里配置一下静态文件的目录。在 <code>STATIC_URL</code> 添加以下内容：</p>
<pre><code>STATIC_URL = '/static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
</code></pre>
<p>这里可以回忆一下，<code>TEMPLATES</code> 配置目录的路径，操作是差不多的。</p>
<p>现在我们必须在模板中加载静态文件（Bootstrap CSS文件）：</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code>{% load static %}&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/bootstrap.min.css' %}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- body suppressed for brevity ... --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>首先，我们在 html 的开头加载静态文件：<code>{% load static %}</code></p>
<p><code>{% static %}</code> 是用于告诉资源文件存在的路径，在这是，<code>{% static 'css/bootstrap.min.css' %}</code> 就会返回 <strong>/static/css/bootstrap.min.css</strong> ，相当于 <strong>http://127.0.0.1:8000/static/css/bootstrap.min.css</strong></p>
<p>这个 <code>{% static %}</code> 标签将会和 <strong>settings.py</strong> 的 <code>STATIC_URL</code> 组成最终的 URL。怎么理解这句话呢？</p>
<p>例如，我们在静态文件托管在 <strong>https://static.example.com/</strong> ，然后我们设置了这个属性：<code>STATIC_URL=https://static.example.com/</code>，然后 <code>{% static 'css/bootstrap.min.css' %}</code> 返回的是 ：<strong>https://static.example.com/css/bootstrap.min.css</strong>。</p>
<p>如果还不能理解，放心，你现在只需要了解和记住相关的过程就行了，后面正式开发上线的时候，会继续开展这部分的内容。</p>
<p>刷新页面 <strong>127.0.0.1:8000</strong> 我们可以看到它是这个样子的：</p>
<figure data-type="image" tabindex="24"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap.png" alt="Boards主页Bootstrap" loading="lazy"></figure>
<p>现在我们可以编辑模板，以利用Bootstrap CSS：</p>
<p>现在我们可以利用 Bootstrap CSS 来编辑我们的模板页面了：</p>
<pre><code>{% load static %}&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/bootstrap.min.css' %}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;ol class=&quot;breadcrumb my-4&quot;&gt;
        &lt;li class=&quot;breadcrumb-item active&quot;&gt;Boards&lt;/li&gt;
      &lt;/ol&gt;
      &lt;table class=&quot;table&quot;&gt;
        &lt;thead class=&quot;thead-inverse&quot;&gt;
          &lt;tr&gt;
            &lt;th&gt;Board&lt;/th&gt;
            &lt;th&gt;Posts&lt;/th&gt;
            &lt;th&gt;Topics&lt;/th&gt;
            &lt;th&gt;Last Post&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {% for board in boards %}
            &lt;tr&gt;
              &lt;td&gt;
                {{ board.name }}
                &lt;small class=&quot;text-muted d-block&quot;&gt;{{ board.description }}&lt;/small&gt;
              &lt;/td&gt;
              &lt;td class=&quot;align-middle&quot;&gt;0&lt;/td&gt;
              &lt;td class=&quot;align-middle&quot;&gt;0&lt;/td&gt;
              &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
          {% endfor %}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>修改后变成这样子：</p>
<figure data-type="image" tabindex="25"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-2.png" alt="Boards主页Bootstrap" loading="lazy"></figure>
<p>到目前为止，我们使用交互式控制台（<code>python manage.py shell</code>）添加新的版块（board）。但是这样很不方便，因此我们需要一个更好的方式来做这个。在下一节中，我们将为网站管理员实施一个管理界面来管理它。</p>
<hr>
<h4 id="django-admin简介">Django Admin简介</h4>
<p>当我们开始一个新项目时，Django 在 <code>INSTALLED_APPS</code> 中已经配置了 <strong>Django Admin</strong> 。</p>
<figure data-type="image" tabindex="26"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Django_Admin.png" alt="Django Admin漫画" loading="lazy"></figure>
<p>Django Admin 的一个很好的用例就是，在博客中，它可以被作者用来编写和发布文章。另一个例子是电子商务网站，工作人员可以创建，编辑，删除产品。</p>
<p>目前，我们将配置 Django Admin 来维护我们的应用程序的版块模块。</p>
<p>我们首先创建一个管理员帐户：</p>
<pre><code>python manage.py createsuperuser
</code></pre>
<p>按照说明操作：</p>
<pre><code>Username (leave blank to use 'vitorfs'): admin
Email address: admin@example.com
Password:
Password (again):
Superuser created successfully.
</code></pre>
<p>现在在浏览器中打开 URL：<strong>http://127.0.0.1:8000/admin/</strong></p>
<figure data-type="image" tabindex="27"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-login.png" alt="Django管理员登录" loading="lazy"></figure>
<p>输入 <strong>用户名</strong> 和 <strong>密码</strong> ：</p>
<figure data-type="image" tabindex="28"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin.png" alt="Django Admin" loading="lazy"></figure>
<p>在这里，它已经配置了一些功能，我们也可以添加<strong>用户</strong>和<strong>组</strong>来管理权限。</p>
<p>那么我们如何在这个管理后台中管理版块（Board）里面的内容呢？</p>
<p>其实很简单，在 <strong>board</strong> 目录下，<strong>admin.py</strong> 中添加以下代码：</p>
<blockquote>
<p><strong>boards/admin.py</strong></p>
</blockquote>
<pre><code>from django.contrib import admin
from .models import Board

admin.site.register(Board)
</code></pre>
<p>保存以下，然后刷新网页：</p>
<figure data-type="image" tabindex="29"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards.png" alt="Django管理委员会" loading="lazy"></figure>
<p>点击 <strong>Boards</strong> 链接就能查看现有版块列表：</p>
<figure data-type="image" tabindex="30"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list.png" alt="Django管理委员会名单" loading="lazy"></figure>
<p>我们可以通过点击 <strong>Add Board</strong> 按钮添加一个新的版块：</p>
<figure data-type="image" tabindex="31"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-add.png" alt="Django管理委员会添加" loading="lazy"></figure>
<p>点击 <strong>SAVE</strong> 按钮：</p>
<figure data-type="image" tabindex="32"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list-2.png" alt="Django管理委员会名单" loading="lazy"></figure>
<p>我们可以检查一切是否正常，打开 <strong>http://127.0.0.1:8000</strong> URL：</p>
<figure data-type="image" tabindex="33"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-3.png" alt="董事会主页" loading="lazy"></figure>
<hr>
<h4 id="结论">结论</h4>
<p>在本教程中，我们探讨了许多新概念。我们为我们的项目定义了一些要求，创建了第一个模型，迁移了数据库，开始玩 Models API。我们创建了第一个视图并编写了一些单元测试。我们还配置了 Django 模板引擎，静态文件，并将 Bootstrap 4 库添加到项目中。最后，我们简要介绍了 Django Admin 界面。</p>
<p>该项目的源代码在 GitHub 上,你可以在下面的链接中找到本章节的代码：</p>
<p><a href="https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw">https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个完整的初学者指南Django-part1]]></title>
        <id>https://dupl.github.io/gridea/post/一个完整的初学者指南Django-part1/</id>
        <link href="https://dupl.github.io/gridea/post/一个完整的初学者指南Django-part1/">
        </link>
        <updated>2025-02-20T12:50:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>源自：https://simpleisbetterthancomplex.com/series/2017/09/04/a-complete-beginners-guide-to-django-part-1.html</p>
</blockquote>
<h3 id="一个完整的初学者指南django-第1部分">一个完整的初学者指南Django - 第1部分</h3>
<figure data-type="image" tabindex="1"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/featured.jpg" alt="一个完整的初学者指南Django  - 第1部分" loading="lazy"></figure>
<p><img src="https://img.shields.io/badge/python-3.6.2-brightgreen.svg" alt="Python 3.6.2" loading="lazy"> <img src="https://img.shields.io/badge/django-1.11.4-brightgreen.svg" alt="Django 1.11.4" loading="lazy"></p>
<h4 id="介绍">介绍</h4>
<figure data-type="image" tabindex="2"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Welcome_Class.png" alt="欢迎班" loading="lazy"></figure>
<p>今天我将开始一个关于 Django 基础知识的新系列教程。这是一个完整的 Django 初学者指南。材料分为七个部分。我们将从安装，开发环境准备，模型，视图，模板，URL 到更高级主题（如迁移，测试和部署）来探索所有基本概念。</p>
<p>我想做一些不同的事情。一个教程，易于遵循，信息丰富和有趣的阅读。因此我想出了在文章中创建一些漫画的想法来说明一些概念和场景。希望你喜欢这种阅读方式！</p>
<p>但在我们开始之前......</p>
<p>我想通过孔夫子的名言来开始我们的课程：</p>
<blockquote>
<p>我听见了，我就忘了</p>
<p>我看见了，我就记得了</p>
<p>我去做了，我就理解了</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Confucius_Quote.png" alt="孔子名言" loading="lazy"></figure>
<p>所以，一定要动手！不要只阅读教程。让我们一起来实操，这样你将通过做和练会学习到更多的知识。</p>
<hr>
<h4 id="为什么选择-django">为什么选择 Django？</h4>
<p>Django 是一个用 Python 编写的 Web 框架。这个 Web 框架支持动态网站，应用程序和服务开发。它提供了一组工具和功能，可解决许多与 Web 开发相关的常见问题，例如安全功能，数据库访问，会话，模板处理，URL 路由，国际化，本地化等等。</p>
<p>使用诸如 Django 之类的 Web 框架，能使我们能够以标准化的方式快速开发安全可靠的Web 应用程序，从而无需重新开发。</p>
<p>那么，Django 有什么特别之处呢？</p>
<p>对于初学者来说，这是一个 Python Web 开源框架，这意味着您可以从各种各样的开源库中受益。在<a href="https://pypi.python.org/pypi">python软件资料库(pypi)</a> 中托管了超过 <strong>11.6万</strong> 个的包（按照 2017 年 9 月 6 日的数据）。如果你需要解决一个特定问题的时候，可能已经有相关的库给你使用。</p>
<p>Django 是用 Python 编写的最流行的 Web 框架之一。它可以提供各种功能，例如用于开发和测试的独立 Web 服务器，缓存，中间件系统，ORM，模板引擎，表单处理，基于 Python 单元测试工具的接口。Django 还附带了电池，提供内置应用程序，如认证系统，具有自动生成<code>CRUD</code>(增删改除)操作页面的管理界面，生成订阅文档（RSS / Atom），站点地图等。甚至在 Django 中建立了一个地理信息系统（GIS）框架。</p>
<p>而且 Django 的开发得到了 <a href="https://www.djangoproject.com/foundation/">Django软件基金会的</a>支持，并且由 JetBrains 和 Instagram 等公司赞助。Django 到目前为止，已经持续开发维护超过12年了，这足以证明它是一个成熟，可靠和安全的 Web 框架。</p>
<h5 id="谁在使用django">谁在使用Django？</h5>
<p>为什么要知道谁在使用 Django 呢？</p>
<p>因为这能很好的让我们了解和知道它能做些什么？</p>
<p>在使用 Django 的最大网站中，有：<a href="https://instagram.com/">Instagram</a>， <a href="https://disqus.com/">Disqus</a>，<a href="https://www.mozilla.org/">Mozilla</a>， <a href="https://bitbucket.org/">Bitbucket</a>，<a href="https://www.last.fm/">Last.fm</a>， <a href="http://www.nationalgeographic.com/">National Geographic</a>。</p>
<p>当然，远远不止上面列举的这些，你可以看下 <a href="https://www.djangosites.org/">Django Sites</a> 数据库，它们提供了超过 <strong>5000</strong> 个 Django 支持的 Web站点的列表。</p>
<p>顺便说一下，去年在 Django Under The Hood 2016 大会上，Django 核心开发人员Carl Meyer 和 Instagram 员工就<a href="https://www.youtube.com/watch?v=lx5WQjXLlq8">如何在规模上使用Django</a> 以及它如何支持其增长展开了一次演讲。这是一个长达一个小时的谈话，如果你有兴趣的话，可以去了解下。</p>
<hr>
<h4 id="安装">安装</h4>
<p>如果我们想开始使用 Django ，那么我们需要安装一些应用程序，包括安装 <strong>Python</strong>，<strong>Virtualenv</strong> 和 <strong>Django</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Basic_Setup.png" alt="基本设置" loading="lazy"></figure>
<p>一开始，强烈建议使用虚拟环境，虽然不是强制性的，可是这对于初学者来说，是一个很好的开端.</p>
<p>在使用 Django 开发 Web 站点或 Web 项目时，必须安装外部库以支持开发是非常常见的。使用虚拟环境，您开发的每个项目都会有其独立的环境。所以依赖关系不会发生冲突。它还允许您维护在不同 Django 版本上运行的本地计算机项目。</p>
<h5 id="安装python-362">安装Python 3.6.2</h5>
<p>我们想要做的第一件事是安装最新的  Python 发行版，它是 <strong>Python 3.6.2</strong>。至少在我写这篇教程的时候是这样。如果有更新的版本，请与它一起使用。接下来的步骤应该保持大致相同。</p>
<p>我们将使用 Python 3，因为最重要的 Python 库已经移植到 Python 3，并且下一个主要的 Django 版本（2.x）不再支持 Python 2。所以 Python 3 是很有必要的。</p>
<p>在 Mac 中，最好的安装方法就是 <a href="https://brew.sh/">Homebrew</a>。如果您还没有在Mac 上安装它，请在 <strong>终端</strong> 运行以下命令：</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>如果您没有安装<strong>命令行工具<code>(Command Line Tools)</code></strong>，则 Homebrew 安装可能需要更长一点时间。但它会自动处理，所以不用担心。请坐下来等到安装完成。</p>
<p>当您看到以下消息时，您会知道安装何时完成：</p>
<pre><code>==&gt; Installation successful!

==&gt; Homebrew has enabled anonymous aggregate user behaviour analytics.
Read the analytics documentation (and how to opt-out) here:
  https://docs.brew.sh/Analytics.html

==&gt; Next steps:
- Run `brew help` to get started
- Further documentation:
    https://docs.brew.sh
</code></pre>
<p>请运行以下命令来安装Python 3：</p>
<pre><code>brew install python3
</code></pre>
<p>由于 macOS 已经安装了Python 2，所以在安装 Python 3 之后，您将可以使用这两个版本。</p>
<p>要运行 Python 2，请使用<code>python</code>终端中的命令。对于 Python 3，请<code>python3</code>改用。</p>
<p>我们可以通过在终端中输入来测试安装：</p>
<pre><code>python3 --version
Python 3.6.2
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/test-python.png" alt="macOS测试Python 3" loading="lazy"></figure>
<p>到此时，Python 已经安装完成了。进入下一步：虚拟环境！</p>
<h5 id="安装-virtualenv">安装 Virtualenv</h5>
<p>接下来这一步，我们将通过 <strong>pip</strong>(一个管理和安装Python包的工具)来安装<strong>Virtualenv</strong>。</p>
<p>请注意，Homebrew 已经为您的 Python 3.6.2 安装了 <code>pip3</code>。</p>
<p>在终端中，执行下面的命令：</p>
<pre><code>sudo pip3 install virtualenv
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/pip-virtualenv.png" alt="pip3安装virtualenv" loading="lazy"></figure>
<p>到目前为止，我们执行的操作都是在系统环境下的。不过，从这一刻起，我们安装的所有东西，包括 Django 本身，都将安装在虚拟环境中。</p>
<p>你可以这样想像一下：对于每个 diango 项目，我们都会为它创建一个虚拟环境。这就好比每个 Django 项目都是一个独立的沙盒，你可以在这个沙盒里随意的玩，安装软件包，卸载软件包，不管怎么对系统环境都不会有任何影响，也不会对其他项目有影响。</p>
<p>我个人喜欢在我的电脑上创建一个 <strong>Development</strong> 的文件夹，然后在这个文件夹下存放我的所有项目。当然，你也可以根据下面的步骤来创建你个人的目录。</p>
<p>通常，我会在我的 <strong>Development</strong> 文件夹中创建一个项目名称的新文件夹。竟然这是我们的第一个项目，就直接将项目名称起为 <strong>myproject</strong>。</p>
<pre><code>mkdir myproject
cd myproject
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/myproject.png" alt="创建myproject文件夹" loading="lazy"></figure>
<p>该文件夹将存储与 Django 项目相关的所有文件，包括其虚拟环境。</p>
<p>接下来，我们将开始创建我们第一个虚拟环境和安装 Django。</p>
<p>在 <strong>myproject</strong> 文件夹中，我们创建一个基于 python 3 的虚拟环境。</p>
<pre><code>virtualenv venv -p python3
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/venv.png" alt="VIRTUALENV" loading="lazy"></figure>
<p>如上图所示，我们的虚拟环境已创建完成。那么我们将如何使用它呢？</p>
<p>当然，我们先开启虚拟环境啦，可以通过以下命令来激活一下虚拟环境：</p>
<pre><code>source venv/bin/activate
</code></pre>
<p>如果你在命令行的前面看到 <strong>（venv）</strong>，就说明，虚拟环境激活成功，现在已经进入到虚拟环境里面了。如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/activate.png" alt="Virtualenv激活" loading="lazy"></figure>
<p>那么这里面到底发生了什么呢？</p>
<p>其实这里我们首先创建了名为 <strong>venv</strong> 的特殊文件夹，这个文件夹里面有 python 的副本，当我们激活 <strong>venv</strong> 环境之后，运行 <code>Python</code> 命令时，它使用的是存储在 <strong>venv</strong> 里面 <code>Python</code> 环境 ，而不是我们装在操作系统上的。</p>
<p>如果在该环境下，我们使用 <strong>PIP</strong> 安装 python 软件包，比如 Django ，那么它是被安装在 <strong>venv</strong> 的虚拟环境上的。</p>
<p>这里有一点需要注意的，当我们启动了 <strong>venv</strong> 这个虚拟环境后，我们使用命令 <code>python</code> 就能调用 python 3.6.2 ，而且也仅仅使用 <code>pip</code>（而不是<code>pip3</code>）来安装软件包。</p>
<p>那么如果我们想退出 <strong>venv</strong> 虚拟环境，该如何操作呢？</p>
<p>只要运行以下命令就可以：</p>
<pre><code>deactivate
</code></pre>
<p>不过，现在我们先不退出虚拟环境 <strong>venv</strong> ，保持着虚拟环境的激活状态，开始下一步操作。</p>
<h5 id="安装django-1114">安装Django 1.11.4</h5>
<p>现在我们来安装以下 Django 1.11.4 ，因为我们已经开启了虚拟环境 <strong>venv</strong> ，因此，这操作会非常的简单。我们将运行下面的命令来安装 Django ：</p>
<pre><code>pip install django
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/mac/pip-django.png" alt="pip安装django" loading="lazy"></figure>
<p>安装成功了，现在一切都准备就绪了！</p>
<figure data-type="image" tabindex="11"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_End_Installation.png" alt="结束安装" loading="lazy"></figure>
<hr>
<h4 id="开始一个新项目">开始一个新项目</h4>
<p>要开始一个新的 Django项目，运行下面的命令：</p>
<p>到目前为止，我们终于可以开始一个新的 Django 项目了，运行下面的命令，创建一个 Django 项目：</p>
<pre><code>django-admin startproject myproject
</code></pre>
<p>命令行工具 <strong>django-admin</strong> 会在安装 Django 的时候一起安装的。</p>
<p>当我们运行了上面的命令之后，系统就会自动的为 Django 项目生成基础的文件。</p>
<p>我们可以打开 <strong>myproject</strong> 目录，可以看到具体的文件结构如下所示：</p>
<pre><code>myproject/                  &lt;-- higher level folder
 |-- myproject/             &lt;-- django project folder
 |    |-- myproject/
 |    |    |-- __init__.py
 |    |    |-- settings.py
 |    |    |-- urls.py
 |    |    |-- wsgi.py
 |    +-- manage.py
 +-- venv/                  &lt;-- virtual environment folder
</code></pre>
<p>可以看到，一个初始 Django 的项目由五个文件组成：</p>
<ul>
<li><strong>manage.py</strong>：<strong>django-admin</strong> 是命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。</li>
<li><strong><strong>init</strong>.py</strong>：这个空文件告诉 Python 这个文件夹是一个 Python 包。</li>
<li><strong>settings.py</strong>：这个文件包含了所有的项目配置。我们会一直使用到这个文件。</li>
<li><strong>urls.py</strong>：这个文件负责映射我们项目中的路由和路径。例如，如果您想在 URL <code>/about/</code> 中显示某些内容，则必须先将其映射到此处。</li>
<li><strong>wsgi.py</strong>：该文件是用于部署简单的网关接口。现在我们暂时不用关心它的内容。</li>
</ul>
<p>Django 自带有一个简单的 Web 服务器。在开发过程中非常方便，所以我们不需要安装其他任何软件即可以在本地运行项目。我们可以通过执行命令来运行它：</p>
<pre><code>python manage.py runserver
</code></pre>
<p>现在在 Web 浏览器中打开以下 URL：<strong>http://127.0.0.1:8000</strong>，您应该看到以下页面：</p>
<figure data-type="image" tabindex="12"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/it-worked.png" alt="有效！" loading="lazy"></figure>
<p>这里提醒一点，如果你需要停止服务器，可以 <code>Control + C</code> 点击停止开发服务器。</p>
<hr>
<h4 id="django-的应用">Django 的应用</h4>
<p>在 Django 哲学中，我们有两个重要的概念：</p>
<ul>
<li><strong>app</strong>：是一个可以执行某些操作的 Web 应用程序。一个应用程序通常由一组 models(数据库表)，views(视图)，templates(模板)，tests(测试) 组成。</li>
<li><strong>project</strong>：是配置和应用程序的集合。一个项目可以由多个应用程序或一个应用程序组成。</li>
</ul>
<p>请注意，如果没有一个 project，你就无法运行 Django 应用程序。像博客这样的简单网站可以完全在单个应用程序中编写，例如可以将其命名为 blog或 weblog。</p>
<figure data-type="image" tabindex="13"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/Pixton_Comic_Django_Apps.png" alt="Django应用程序" loading="lazy"></figure>
<p>当然这是组织源代码的一种方式，现在刚入门，判断确定什么是不是应用程序这些还不太重要。包括如何组织代码等，现在都不是担心这些问题的时候。现在，首先让我们先熟悉了解 Django 的 API 和基础知识。</p>
<p>好了，为了更好的了解，我们先来创建一个简单的论坛项目，那么我们要创建一个应用程序，首先要进入到 <strong>manage.py</strong> 文件所在的目录并执行以下命令：</p>
<pre><code>django-admin startapp boards
</code></pre>
<p>请注意，这次我们使用了命令 <strong>startapp</strong>。</p>
<p>这会给我们以下的目录结构：</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/                &lt;-- our new django app!
 |    |    |-- migrations/
 |    |    |    +-- __init__.py
 |    |    |-- __init__.py
 |    |    |-- admin.py
 |    |    |-- apps.py
 |    |    |-- models.py
 |    |    |-- tests.py
 |    |    +-- views.py
 |    |-- myproject/
 |    |    |-- __init__.py
 |    |    |-- settings.py
 |    |    |-- urls.py
 |    |    |-- wsgi.py
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>所以，我们先来看看每个文件的功能：</p>
<ul>
<li><strong>migrations /</strong>：在这个文件夹中，Django 会存储一些文件以跟踪您在 <strong>models.py</strong> 文件中创建的更改，目的是为了保持数据库和 <strong>models.py</strong> 同步。</li>
<li><strong>admin.py</strong>：这是 Django应用程序一个名为 <strong>Django Admin</strong> 的内置配置文件。</li>
<li><strong>apps.py</strong>：这是应用程序本身的配置文件。</li>
<li><strong>models.py</strong>：这里是我们定义 Web 应用程序实体的地方。models  由 Django 自动转换为数据库表。</li>
<li><strong>tests.py</strong>：该文件用于为应用程序编写单元测试。</li>
<li><strong>views.py</strong>：这是我们处理Web应用程序请求(request)/响应(resopnse)周期的文件。</li>
</ul>
<p>现在我们创建了我们的第一个应用程序，让我们来配置一下项目以便启用这个应用程序。</p>
<p>为此，请打开<strong>settings.py</strong>并尝试查找<code>INSTALLED_APPS</code>变量：</p>
<p><strong>settings.py</strong></p>
<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
</code></pre>
<p>正如你所看到的，Django 已经安装了6个内置的应用程序。它们提供大多数Web应用程序所需的常用功能，如身份验证，会话，静态文件管理（图像，JavaScript，CSS等）等。</p>
<p>我们将会在本系列教程中探索这些应用程序。但现在，先不管它们，只需将我们的应用程序 boards 添加到 <code>INSTALLED_APPS</code> 列表即可：</p>
<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'boards',
]
</code></pre>
<p>使用上个漫画中的正方形和圆形的比喻，黄色圆圈将成为我们的 <strong>boards</strong> 应用程序，而 <strong>django.contrib.admin</strong>，<strong>django.contrib.auth</strong> 等将成为红色圆圈。</p>
<hr>
<h4 id="hello-world">Hello, World!</h4>
<p>现在我们先来写一个我们的第一个 <strong>视图（view）</strong> ，那么，现在我们来看看该如何使用 Django 来创建一个新的页面吧。</p>
<p>打开 <strong>boards</strong> 应用程序中的 <strong>views.py</strong> 文件，并添加下面的代码：</p>
<p><strong>views.py</strong></p>
<pre><code class="language-python">from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello, World!')
</code></pre>
<p><strong>视图（view）</strong> 是接收 <code>HttpRequest</code> 对象并返回 <code>HttpResponse</code>对象的 Python 函数。接收 request 作为参数并返回 response 作为结果。这个过程是需要我们记住的。</p>
<p>因此，就像我们上面的代码，我们定义了一个简单的视图，命名为 <code>home</code> ，然后我们简单的返回了一个字符串 <strong>Hello，World！</strong></p>
<p>那么我们直接运行就可以了吗？</p>
<p>并不是的，我们还没有告诉 Django 什么时候调用这个 <strong>视图（view）</strong> 呢？这就需要我们在 <strong>urls.py</strong> 文件中完成：</p>
<p><strong>urls.py</strong></p>
<pre><code class="language-Python">from django.conf.urls import url
from django.contrib import admin

from boards import views

urlpatterns = [
    url(r'^/code&gt;, views.home, name='home'),
    url(r'^admin/', admin.site.urls),
]
</code></pre>
<p>如果您将上面的代码段与您的 <strong>urls.py</strong> 文件进行比较，您会注意到我添加了以下的代码：<code>url(r'^$', views.home, name='home')</code> 并使用我们的应用程序 <strong>boards</strong> 中导入了 <strong>views</strong> 模块。<code>from boards import views</code></p>
<p>可能这里大家还是会有很多疑问，不过先这样做，在后面我们会详细探讨这些概念。</p>
<p>但是现在，Django 使用<strong>正则表达式</strong>来匹配请求的URL。对于我们的 <strong>home</strong> 视图，我使用的是<code>^$</code>正则表达式，它将匹配空白路径，这是主页（此URL：<strong>http://127.0.0.1:8000</strong>）。如果我想匹配URL <strong>http://127.0.0.1:8000/homepage/</strong>，那么我们 url 的正则表达式就应该这样写：<code>url(r'^homepage/$', views.home, name='home')</code>。</p>
<p>运行项目，让我们看看会发生什么：</p>
<pre><code>python manage.py runserver
</code></pre>
<p>在 Web 浏览器中，打开 http://127.0.0.1:8000 ：</p>
<figure data-type="image" tabindex="14"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-1/hello-world.png" alt="你好，世界！" loading="lazy"></figure>
<p>这样我们就看到了我们刚刚创建的第一个界面了。</p>
<hr>
<h4 id="总结">总结</h4>
<p>这是本系列教程的第一部分。在本教程中，我们学习了如何安装最新的 Python 版本以及如何设置开发环境。我们还介绍了虚拟环境，并开始了我们第一个 Django 项目，并已创建了我们的初始应用程序。</p>
<p>我希望你喜欢第一部分！第二部将涉及模型，视图，模板和网址。我们将一起探索所有的Django 基础知识！</p>
<p>就这样我们可以保持在同一页面上，我在 GitHub 上提供了源代码。项目的当前状态可以在发布<strong>release tag v0.1-lw</strong>下找到。下面的链接将带你到正确的地方：</p>
<p><a href="https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw">https://github.com/sibtc/django-beginners-guide/tree/v0.1-lw</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac中使用virtualenv和virtualenvwrapper]]></title>
        <id>https://dupl.github.io/gridea/post/Mac中使用virtualenv和virtualenvwrapper/</id>
        <link href="https://dupl.github.io/gridea/post/Mac中使用virtualenv和virtualenvwrapper/">
        </link>
        <updated>2025-02-20T12:50:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="virtualenv">Virtualenv</h2>
<h3 id="介绍">介绍</h3>
<p>在使用 <code>Python</code> 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。</p>
<p>因此，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。而 <code>virtualenv</code>就是一个可以帮助我们管理不同 <code>Python</code> 环境的绝好工具。<code>virtualenv</code> 可以在系统中建立多个不同并且相互不干扰的虚拟环境。</p>
<h3 id="安装">安装</h3>
<pre><code> pip3 install virtualenv
</code></pre>
<p>这样就成功了</p>
<h3 id="使用">使用</h3>
<h4 id="创建">创建</h4>
<p>假如我们想要用<code>scrapy</code>去爬取某个网站的信息，我们不想再宿主环境总安装scrapy以及requests这些包，那我们就可以使用virtualenv了。</p>
<p>假设我们把这个虚拟环境放在<code>~/workspaces/project_env/spider/</code>目录下</p>
<pre><code> virtualenv ~/workspaces/project_env/spider/
</code></pre>
<p>这样虚拟环境就创建好了，我们可以看到在这个目录下油三个目录被建立</p>
<ul>
<li>bin：包含一些在这个虚拟环境中可用的命令，以及开启虚拟环境的脚本 <code>activate</code></li>
<li>include：包含虚拟环境中的头文件，包括 <code>Python</code> 的头文件</li>
<li>lib：这里面就是一些依赖库</li>
</ul>
<h4 id="激活">激活</h4>
<pre><code> source ~/workspaces/project_env/spider/bin/activate
</code></pre>
<p>此时我们就已经在虚拟环境中了</p>
<p>可以安装一下requests这个模块</p>
<pre><code> pip install requests
</code></pre>
<p>可以看到很快就成功</p>
<h4 id="退出虚拟环境">退出虚拟环境</h4>
<pre><code> deactivate
</code></pre>
<h2 id="virtualenvwrapper">virtualenvwrapper</h2>
<h3 id="介绍-2">介绍</h3>
<p>我们刚才了解了<code>virtualenv</code>，我觉得比较麻烦，每次开启虚拟环境之前要去虚拟环境所在目录下的 <code>bin</code> 目录下 <code>source</code>一下 <code>activate</code>，这就需要我们记住每个虚拟环境所在的目录。</p>
<p>一种可行的解决方案是，将所有的虚拟环境目录全都集中起来，比如放到 <code>~/virtualenvs/</code>，并对不同的虚拟环境使用不同的目录来管理。<code>virtualenvwrapper</code> 正是这样做的。并且，它还省去了每次开启虚拟环境时候的 <code>source</code> 操作，使得虚拟环境更加好用。</p>
<h3 id="安装-2">安装</h3>
<pre><code> pip install virtualwrapper
</code></pre>
<p>这样我们就安装好了可以管理虚拟环境的神器</p>
<h3 id="使用-2">使用</h3>
<h4 id="配置">配置</h4>
<p>首先需要对<code>virtualenvwrapper</code>进行配置:</p>
<ul>
<li>需要指定一个环境变量，叫做<code>WORKON_HOME</code>，它是用来存放各种虚拟环境目录的目录</li>
<li>需要export vitualenvwrapper这个模块存放的位置</li>
<li>需要运行一下它的初始化工具 <code>virtualenvwrapper.sh</code>，可通过<code>which virtualenvwrapper.sh</code>查看位置，我的在<code>/usr/local/bin/</code></li>
</ul>
<p>由于每次都需要执行这两步操作，我们可以将其写入终端的配置文件中。</p>
<p>如果使用 <code>bash</code>，则添加到 <code>~/.bashrc</code> 中</p>
<p>如果使用 <code>zsh</code>，则添加到 <code>~/.zshrc</code> 中</p>
<p>这样每次启动终端的时候都会自动运行，终端启动之后 <code>virtualenvwrapper</code> 就可以用啦</p>
<pre><code> export WORKON_HOME='~/Workspaces/Envs'

 export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3

 source /usr/local/bin/virtualenvwrapper.sh
</code></pre>
<p><strong>创建虚拟机</strong></p>
<pre><code>mkvirtualenv env
</code></pre>
<p>创建虚拟环境完成后，会自动切换到创建的虚拟环境中</p>
<p>当然也可以指定虚拟机的 python 版本</p>
<pre><code>mkvirtualenv env -p C:\python27\python.exe
</code></pre>
<p><strong>列出虚拟环境列表</strong></p>
<pre><code>workon 或者 lsvirtualenv
</code></pre>
<p><strong>启动/切换虚拟环境</strong></p>
<p>使用 workon [virtual-name] 即可切换到对应的虚拟环境</p>
<pre><code>workon [虚拟环境名称]
</code></pre>
<p><strong>删除虚拟环境</strong></p>
<pre><code>rmvirtualenv [虚拟环境名称]
</code></pre>
<p><strong>离开虚拟环境，和 virutalenv 一样的命令</strong></p>
<pre><code>deactivate
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Python虚拟环境]]></title>
        <id>https://dupl.github.io/gridea/post/使用Python虚拟环境/</id>
        <link href="https://dupl.github.io/gridea/post/使用Python虚拟环境/">
        </link>
        <updated>2025-02-20T12:50:14.000Z</updated>
        <content type="html"><![CDATA[<p>python 的虚拟环境可以为一个 python 项目提供独立的解释环境、依赖包等资源，既能够很好的隔离不同项目使用不同 python 版本带来的冲突，而且还能方便项目的发布。</p>
<h1 id="virtualenv">virtualenv</h1>
<p><a href="http://pypi.python.org/pypi/virtualenv">virtualenv</a>可用于创建独立的 Python 环境，它会创建一个包含项目所必须要的执行文件。</p>
<p><strong>安装 virtualenv</strong></p>
<pre><code>$ pip install virtualenv
</code></pre>
<p><strong>配置 pip 安装第三方库的镜像源地址</strong></p>
<p>我们都知道，国内连接国外的服务器都会比较慢，有时候设置下载经常出现超时的情况。这时可以尝试使用国内优秀的<a href="https://pypi.douban.com/simple">豆瓣源</a>镜像来安装。</p>
<p>使用豆瓣源安装 virtualenv</p>
<pre><code>pip install -i https://pypi.douban.com/simple virtualenv
</code></pre>
<p><strong>virtualenv使用方法</strong></p>
<p>如下命令表示在当前目录下创建一个名叫 env 的目录（虚拟环境），该目录下包含了独立的 Python 运行程序,以及 pip副本用于安装其他的 packge</p>
<pre><code>virtualenv env
</code></pre>
<p>当然在创建 env 的时候可以选择 Python 解释器，例如：</p>
<pre><code>virtualenv -p /usr/local/bin/python3 venv
</code></pre>
<p>默认情况下，虚拟环境会依赖系统环境中的 site packages，就是说系统中已经安装好的第三方 package 也会安装在虚拟环境中，如果不想依赖这些 package，那么可以加上参数 <code>--no-site-packages</code> 建立虚拟环境</p>
<pre><code>virtualenv --no-site-packages [虚拟环境名称]
</code></pre>
<p><strong>启动虚拟环境</strong></p>
<pre><code>cd ENV
source ./bin/activate
</code></pre>
<p>注意此时命令行会多一个<code>(ENV)</code>，ENV为虚拟环境名称，接下来所有模块都只会安装到这个虚拟的环境中去。</p>
<p><strong>退出虚拟环境</strong></p>
<pre><code>deactivate
</code></pre>
<p>如果想删除虚拟环境，那么直接运行<code>rm -rf venv/</code>命令即可。</p>
<p><strong>在虚拟环境安装 Python packages</strong></p>
<p>Virtualenv 附带有 pip 安装工具，因此需要安装的 packages 可以直接运行：</p>
<pre><code>pip install [套件名称]
</code></pre>
<h1 id="virtualenvwrapper">Virtualenvwrapper</h1>
<p>Virtualenvwrapper 是一个虚拟环境管理工具，它能够管理创建的虚拟环境的位置，并能够方便地查看虚拟环境的名称以及切换到指定的虚拟环境。</p>
<p><strong>安装（确保virtualenv已经安装）</strong></p>
<pre><code>pip install virtualenvwrapper
</code></pre>
<p>或者使用豆瓣源</p>
<pre><code>pip install -i https://pypi.douban.com/simple virtualenvwrapper-win
</code></pre>
<p>注：</p>
<p>安装需要在非虚拟环境下进行</p>
<p><strong>创建虚拟机</strong></p>
<pre><code>mkvirtualenv env
</code></pre>
<p>创建虚拟环境完成后，会自动切换到创建的虚拟环境中</p>
<p>当然也可以指定虚拟机的 python 版本</p>
<pre><code>mkvirtualenv env -p C:\python27\python.exe
</code></pre>
<p><strong>列出虚拟环境列表</strong></p>
<pre><code>workon 或者 lsvirtualenv
</code></pre>
<p><strong>启动/切换虚拟环境</strong></p>
<p>使用 workon [virtual-name] 即可切换到对应的虚拟环境</p>
<pre><code>workon [虚拟环境名称]
</code></pre>
<p><strong>删除虚拟环境</strong></p>
<pre><code>rmvirtualenv [虚拟环境名称]
</code></pre>
<p><strong>离开虚拟环境，和 virutalenv 一样的命令</strong></p>
<pre><code>deactivate
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python关键字yield]]></title>
        <id>https://dupl.github.io/gridea/post/Python关键字yield/</id>
        <link href="https://dupl.github.io/gridea/post/Python关键字yield/">
        </link>
        <updated>2025-02-20T12:50:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文：http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained</p>
<p>注：这是一篇 stackoverflow 上一个火爆帖子的译文</p>
</blockquote>
<h2 id="问题">问题</h2>
<p>Python 关键字 yield 的作用是什么？用来干什么的？</p>
<p>比如，我正在试图理解下面的代码:</p>
<pre><code class="language-Python">def node._get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild
</code></pre>
<p>下面的是调用:</p>
<pre><code class="language-python">result, candidates = list(), [self]
while candidates:
    node = candidates.pop()
    distance = node._get_dist(obj)
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result
</code></pre>
<p>当调用 <code>_get_child_candidates</code> 的时候发生了什么？返回了一个列表？返回了一个元素？被重复调用了么？ 什么时候这个调用结束呢？</p>
<h2 id="回答">回答</h2>
<p>为了理解什么是 yield ,你必须理解什么是生成器。在理解生成器之前，让我们先走近迭代。</p>
<p><strong>可迭代对象</strong></p>
<p>当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象:</p>
<pre><code class="language-Python">&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; for i in mylist :
...    print(i)
1
2
3
</code></pre>
<p>mylist 是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，就建立了一个可迭代的对象:</p>
<pre><code class="language-python">&gt;&gt;&gt; mylist = [x*x for x in range(3)]
&gt;&gt;&gt; for i in mylist :
...    print(i)
0
1
4
</code></pre>
<p>所有你可以使用 <code>for .. in ..</code> 语法的叫做一个迭代器：列表，字符串，文件……你经常使用它们是因为你可以如你所愿的读取其中的元素，但是你把所有的值都存储到了内存中，如果你有大量数据的话这个方式并不是你想要的。</p>
<p><strong>生成器</strong></p>
<p>生成器是可以迭代的，但是你 只可以读取它一次 ，因为它并不把所有的值放在内存中，它是实时地生成数据:</p>
<pre><code class="language-python">&gt;&gt;&gt; mygenerator = (x*x for x in range(3))
&gt;&gt;&gt; for i in mygenerator :
...    print(i)
0
1
4
</code></pre>
<p>看起来除了把 [] 换成 () 外没什么不同。但是，你不可以再次使用 <code>for i in mygenerator</code> , 因为生成器只能被迭代一次：先计算出0，然后继续计算1，然后计算4，一个跟一个的…</p>
<p><strong>yield 关键字</strong></p>
<p>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器。</p>
<pre><code class="language-python">&gt;&gt;&gt; def createGenerator() :
...    mylist = range(3)
...    for i in mylist :
...        yield i*i
...
&gt;&gt;&gt; mygenerator = createGenerator() # create a generator
&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!
&lt;generator object createGenerator at 0xb7555c34&gt;
&gt;&gt;&gt; for i in mygenerator:
...     print(i)
0
1
4
</code></pre>
<p>这个例子没什么用途，但是它让你知道，这个函数会返回一大批你只需要读一次的值.</p>
<p>为了精通 yield ,你必须要理解：当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象，这有点蹊跷不是吗。</p>
<p>那么，函数内的代码什么时候执行呢？当你使用for进行迭代的时候.</p>
<p>现在到了关键点了！</p>
<p>第一次迭代中你的函数会执行，从开始到达 yield 关键字，然后返回 yield 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。</p>
<p>如果生成器内部没有定义 yield 关键字，那么这个生成器被认为成空的。这种情况可能因为是循环进行没了，或者是没有满足 if/else 条件。</p>
<p><strong>回到你的代码</strong></p>
<p>生成器:</p>
<pre><code class="language-Python"># Here you create the method of the node object that will return the generator
def node._get_child_candidates(self, distance, min_dist, max_dist):

  # Here is the code that will be called each time you use the generator object :

  # If there is still a child of the node object on its left
  # AND if distance is ok, return the next child
  if self._leftchild and distance - max_dist &lt; self._median:
            yield self._leftchild

  # If there is still a child of the node object on its right
  # AND if distance is ok, return the next child
  if self._rightchild and distance + max_dist &gt;= self._median:
                yield self._rightchild

  # If the function arrives here, the generator will be considered empty
  # there is no more than two values : the left and the right children
</code></pre>
<p>调用者:</p>
<pre><code class="language-Python"># Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning)
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If distance is ok, then you can fill the result
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)

    # Add the children of the candidate in the candidates list
    # so the loop will keep running until it will have looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result
</code></pre>
<p>这个代码包含了几个小部分：</p>
<ul>
<li>我们对一个列表进行迭代，但是迭代中列表还在不断的扩展。它是一个迭代这些嵌套的数据的简洁方式，即使这样有点危险，因为可能导致无限迭代。 <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> 穷尽了生成器的所有值，但 while 不断地在产生新的生成器，它们会产生和上一次不一样的值，既然没有作用到同一个节点上.</li>
<li><code>extend()</code> 是一个迭代器方法，作用于迭代器，并把参数追加到迭代器的后面。</li>
</ul>
<p>通常我们传给它一个列表参数:</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; b = [3, 4]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; print(a)
[1, 2, 3, 4]
</code></pre>
<p>但是在你的代码中的是一个生成器，这是不错的，因为：</p>
<ul>
<li>你不必读两次所有的值</li>
<li>你可以有很多子对象，但不必叫他们都存储在内存里面。</li>
</ul>
<p>并且这很奏效，因为 Python 不关心一个方法的参数是不是个列表。Python 只希望它是个可以迭代的，所以这个参数可以是列表，元组，字符串，生成器... 这叫做 <code>duck typing</code>,这也是为何 Python 如此棒的原因之一，但这已经是另外一个问题了...</p>
<p>你可以在这里停下，来看看生成器的一些高级用法:</p>
<p><strong>控制生成器的穷尽</strong></p>
<pre><code class="language-Python">&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self) :
...        while not self.crisis :
...            yield &quot;$100&quot;
&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want
&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs
&gt;&gt;&gt; print(wall_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business
&gt;&gt;&gt; for cash in brand_new_atm :
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...
</code></pre>
<p>对于控制一些资源的访问来说这很有用。</p>
<p><strong>Itertools,你最好的朋友</strong></p>
<p>itertools 包含了很多特殊的迭代方法。是不是曾想过复制一个迭代器?串联两个迭代器？把嵌套的列表分组？不用创造一个新的列表的 zip/map?</p>
<p>只要 import itertools</p>
<p>需要个例子？让我们看看比赛中4匹马可能到达终点的先后顺序的可能情况:</p>
<pre><code class="language-python">&gt;&gt;&gt; horses = [1, 2, 3, 4]
&gt;&gt;&gt; races = itertools.permutations(horses)
&gt;&gt;&gt; print(races)
&lt;itertools.permutations object at 0xb754f1dc&gt;
&gt;&gt;&gt; print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]
</code></pre>
<p><strong>了解迭代器的内部机理</strong></p>
<p>迭代是一个实现可迭代对象(实现的是 <code>__iter__()</code> 方法)和迭代器(实现的是 <code>__next__()</code> 方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[16-1]]></title>
        <id>https://dupl.github.io/gridea/post/16-1/</id>
        <link href="https://dupl.github.io/gridea/post/16-1/">
        </link>
        <updated>2025-02-20T12:50:12.000Z</updated>
        <content type="html"><![CDATA[<p>上一篇文章将通过解决一个需求问题来了解了闭包，本文也将一样，通过慢慢演变一个需求，一步一步来了解 Python 装饰器。</p>
<p>首先有这么一个输出员工打卡信息的函数：</p>
<pre><code class="language-Python">def punch():
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')


punch()
</code></pre>
<p>输出的结果如下：</p>
<pre><code>昵称：两点水  部门：做鸭事业部 上班打卡成功
</code></pre>
<p>然后，产品反馈，不行啊，怎么上班打卡没有具体的日期，加上打卡的具体日期吧，这应该很简单，分分钟解决啦。好吧，那就直接添加打印日期的代码吧，如下：</p>
<pre><code class="language-Python">import time


def punch():
    print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')


punch()
</code></pre>
<p>输出结果如下：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
</code></pre>
<p>这样改是可以，可是这样改是改变了函数的功能结构的，本身这个函数定义的时候就是打印某个员工的信息和提示打卡成功，现在增加打印日期的代码，可能会造成很多代码重复的问题。比如，还有一个地方只需要打印员工信息和打卡成功就行了，不需要日期，那么你又要重写一个函数吗？而且打印当前日期的这个功能方法是经常使用的，是可以作为公共函数给各个模块方法调用的。当然，这都是作为一个整体项目来考虑的。</p>
<p>既然是这样，我们可以使用函数式编程来修改这部分的代码。因为通过之前的学习，我们知道 Python 函数有两个特点，函数也是一个对象，而且函数里可以嵌套函数，那么修改一下代码变成下面这个样子：</p>
<pre><code class="language-Python">import time


def punch():
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')


def add_time(func):
    print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
    func()


add_time(punch)
</code></pre>
<p>输出结果：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
</code></pre>
<p>这样是不是发现，这样子就没有改动 <code>punch</code> 方法，而且任何需要用到打印当前日期的函数都可以把函数传进 <code>add_time</code> 就可以了，就比如这样：</p>
<pre><code class="language-Python">import time


def punch():
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')


def add_time(func):
    print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
    func()


def holiday():
    print('天气太冷，今天放假')


add_time(punch)
add_time(holiday)

</code></pre>
<p>打印结果：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
2018-01-09
天气太冷，今天放假
</code></pre>
<p>使用函数编程是不是很方便，但是，我们每次调用的时候，我们都不得不把原来的函数作为参数传递进去，还能不能有更好的实现方式呢？有的，就是本文要介绍的装饰器，因为装饰器的写法其实跟闭包是差不多的，不过没有了自由变量，那么这里直接给出上面那段代码的装饰器写法，来对比一下，装饰器的写法和函数式编程有啥不同。</p>
<pre><code class="language-Python">import time


def decorator(func):
    def punch():
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func()

    return punch


def punch():
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')


f = decorator(punch)
f()
</code></pre>
<p>输出的结果：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
</code></pre>
<p>通过代码，能知道装饰器函数一般做这三件事：</p>
<ol>
<li>接收一个函数作为参数</li>
<li>嵌套一个包装函数, 包装函数会接收原函数的相同参数，并执行原函数，且还会执行附加功能</li>
<li>返回嵌套函数</li>
</ol>
<p>可是，认真一看这代码，这装饰器的写法怎么比函数式编程还麻烦啊。而且看起来比较复杂，甚至有点多此一举的感觉。</p>
<p>那是因为我们还没有用到装饰器的 “语法糖” ，我们看上面的代码可以知道， Python 在引入装饰器 （Decorator） 的时候，没有引入任何新的语法特性，都是基于函数的语法特性。这也就说明了装饰器不是 Python 特有的，而是每个语言通用的一种编程思想。只不过 Python 设计出了 <code>@</code> 语法糖，让 定义装饰器，把装饰器调用原函数再把结果赋值为原函数的对象名的过程变得更加简单，方便，易操作，所以 Python 装饰器的核心可以说就是它的语法糖。</p>
<p>那么怎么使用它的语法糖呢？很简单，根据上面的写法写完装饰器函数后，直接在原来的函数上加 <code>@</code> 和装饰器的函数名。如下：</p>
<pre><code class="language-Python">import time


def decorator(func):
    def punch():
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func()

    return punch

@decorator
def punch():
    print('昵称：两点水  部门：做鸭事业部 上班打卡成功')

punch()
</code></pre>
<p>输出结果：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
</code></pre>
<p>那么这就很方便了，方便在我们的调用上，比如例子中的，使用了装饰器后，直接在原本的函数上加上装饰器的语法糖就可以了，本函数也无虚任何改变，调用的地方也不需修改。</p>
<p>不过这里一直有个问题，就是输出打卡信息的是固定的，那么我们需要通过参数来传递，装饰器该怎么写呢？装饰器中的函数可以使用 <code>*args</code> 可变参数，可是仅仅使用 <code>*args</code> 是不能完全包括所有参数的情况，比如关键字参数就不能了，为了能兼容关键字参数，我们还需要加上 <code>**kwargs</code> 。</p>
<p>因此，装饰器的最终形式可以写成这样：</p>
<pre><code class="language-Python">import time


def decorator(func):
    def punch(*args, **kwargs):
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func(*args, **kwargs)

    return punch


@decorator
def punch(name, department):
    print('昵称：{0}  部门：{1} 上班打卡成功'.format(name, department))


@decorator
def print_args(reason, **kwargs):
    print(reason)
    print(kwargs)


punch('两点水', '做鸭事业部')
print_args('两点水', sex='男', age=99)
</code></pre>
<p>输出结果如下：</p>
<pre><code>2018-01-09
昵称：两点水  部门：做鸭事业部 上班打卡成功
2018-01-09
两点水
{'sex': '男', 'age': 99}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[15-1]]></title>
        <id>https://dupl.github.io/gridea/post/15-1/</id>
        <link href="https://dupl.github.io/gridea/post/15-1/">
        </link>
        <updated>2025-02-20T12:50:11.000Z</updated>
        <content type="html"><![CDATA[<p>网络上介绍 Python 闭包的文章已经很多了，本文将通过解决一个需求问题来了解闭包。</p>
<p>这个需求是这样的，我们需要一直记录自己的学习时间，以分钟为单位。就好比我学习了 2 分钟，就返回 2 ，然后隔了一阵子，我学习了 10 分钟，那么就返回 12 ，像这样把学习时间一直累加下去。</p>
<p>面对这个需求，我们一般都会创建一个全局变量来记录时间，然后用一个方法来新增每次的学习时间，通常都会写成下面这个形式：</p>
<pre><code class="language-Python">time = 0

def insert_time(min):
    time = time + min
    return  time

print(insert_time(2))
print(insert_time(10))
</code></pre>
<p>认真想一下，会不会有什么问题呢？</p>
<p>其实，这个在 Python 里面是会报错的。会报如下错误：</p>
<pre><code>UnboundLocalError: local variable 'time' referenced before assignment
</code></pre>
<p>那是因为，在 Python 中，如果一个函数使用了和全局变量相同的名字且改变了该变量的值，那么该变量就会变成局部变量，那么就会造成在函数中我们没有进行定义就引用了，所以会报该错误。</p>
<p>如果确实要引用全局变量，并在函数中对它进行修改，该怎么做呢？</p>
<p>我们可以使用 <code>global</code> 关键字,具体修改如下：</p>
<pre><code class="language-Python">time = 0


def insert_time(min):
    global  time
    time = time + min
    return  time

print(insert_time(2))
print(insert_time(10))
</code></pre>
<p>输出结果如下：</p>
<pre><code>2
12
</code></pre>
<p>可是啊，这里使用了全局变量，我们在开发中能尽量避免使用全局变量的就尽量避免使用。因为不同模块，不同函数都可以自由的访问全局变量，可能会造成全局变量的不可预知性。比如程序员甲修改了全局变量 <code>time</code> 的值，然后程序员乙同时也对 <code>time</code> 进行了修改，如果其中有错误，这种错误是很难发现和更正的。</p>
<p>全局变量降低了函数或模块之间的通用性，不同的函数或模块都要依赖于全局变量。同样，全局变量降低了代码的可读性，阅读者可能并不知道调用的某个变量是全局变量。</p>
<p>那有没有更好的方法呢？</p>
<p>这时候我们使用闭包来解决一下，先直接看代码：</p>
<pre><code class="language-python">time = 0


def study_time(time):
    def insert_time(min):
        nonlocal  time
        time = time + min
        return time

    return insert_time


f = study_time(time)
print(f(2))
print(time)
print(f(10))
print(time)
</code></pre>
<p>输出结果如下:</p>
<pre><code>2
0
12
0
</code></pre>
<p>这里最直接的表现就是全局变量 <code>time</code> 至此至终都没有修改过,这里还是用了 <code>nonlocal</code> 关键字,表示在函数或其他作用域中使用外层(非全局)变量。那么上面那段代码具体的运行流程是怎样的。我们可以看下下图：</p>
<figure data-type="image" tabindex="1"><img src="http://twowaterimage.oss-cn-beijing.aliyuncs.com/2019-10-14-Python%20%E9%97%AD%E5%8C%85%E8%A7%A3%E5%86%B3.png" alt="" loading="lazy"></figure>
<p>这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭包。更加直接的表达方式就是，当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。k</p>
<p>闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。而且使用闭包，可以使代码变得更加的优雅。而且下一篇讲到的装饰器，也是基于闭包实现的。</p>
<p>到这里，就会有一个问题了，你说它是闭包就是闭包了？有没有什么办法来验证一下这个函数就是闭包呢？</p>
<p>有的，所有函数都有一个 <code> __closure__</code> 属性，如果函数是闭包的话，那么它返回的是一个由 cell 组成的元组对象。cell 对象的 cell_contents 属性就是存储在闭包中的变量。</p>
<p>我们打印出来体验一下：</p>
<pre><code class="language-Python">time = 0


def study_time(time):
    def insert_time(min):
        nonlocal  time
        time = time + min
        return time

    return insert_time


f = study_time(time)
print(f.__closure__)
print(f(2))
print(time)
print(f.__closure__[0].cell_contents)
print(f(10))
print(time)
print(f.__closure__[0].cell_contents)
</code></pre>
<p>打印的结果为：</p>
<pre><code>(&lt;cell at 0x0000000000410C48: int object at 0x000000001D6AB420&gt;,)
2
0
2
12
0
12
</code></pre>
<p>从打印结果可见，传进来的值一直存储在闭包的 cell_contents 中,因此，这也就是闭包的最大特点，可以将父函数的变量与其内部定义的函数绑定。就算生成闭包的父函数已经释放了，闭包仍然存在。</p>
<p>闭包的过程其实好比类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[14-6]]></title>
        <id>https://dupl.github.io/gridea/post/14-6/</id>
        <link href="https://dupl.github.io/gridea/post/14-6/">
        </link>
        <updated>2025-02-20T12:50:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rematch-和-research">re.match  和 re.search</h1>
<p><strong>re.match 函数</strong></p>
<p>语法：</p>
<pre><code class="language-python">re.match(pattern, string, flags=0)
</code></pre>
<p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match() 就返回 none。</p>
<p><strong>re.search 函数</strong></p>
<p>语法：</p>
<pre><code class="language-Python">re.search(pattern, string, flags=0)
</code></pre>
<p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>re.match 和 re.search 的参数，基本一致的，具体描述如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写</td>
</tr>
</tbody>
</table>
<p>那么它们之间有什么区别呢？</p>
<p>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None；而 re.search 匹配整个字符串，直到找到一个匹配。这就是它们之间的区别了。</p>
<p>re.match 和 re.search 在网上有很多详细的介绍了，可是再个人的使用中，还是喜欢使用  re.findall</p>
<p>看下下面的实例，可以对比下 re.search 和 re.findall 的区别，还有多分组的使用。具体看下注释，对比一下输出的结果：</p>
<p>示例：</p>
<pre><code class="language-python">
#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

# 提取图片的地址

import re

a = '&lt;img src=&quot;https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg&quot;&gt;'

# 使用 re.search
search = re.search('&lt;img src=&quot;(.*)&quot;&gt;', a)
# group(0) 是一个完整的分组
print(search.group(0))
print(search.group(1))

# 使用 re.findall
findall = re.findall('&lt;img src=&quot;(.*)&quot;&gt;', a)
print(findall)

# 多个分组的使用（比如我们需要提取 img 字段和图片地址字段）
re_search = re.search('&lt;(.*) src=&quot;(.*)&quot;&gt;', a)
# 打印 img
print(re_search.group(1))
# 打印图片地址
print(re_search.group(2))
# 打印 img 和图片地址，以元祖的形式
print(re_search.group(1, 2))
# 或者使用 groups
print(re_search.groups())

</code></pre>
<p>输出的结果：</p>
<pre><code class="language-txt">&lt;img src=&quot;https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg&quot;&gt;
https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg
['https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg']
img
https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg
('img', 'https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg')
('img', 'https://s-media-cache-ak0.pinimg.com/originals/a8/c4/9e/a8c49ef606e0e1f3ee39a7b219b5c05e.jpg')
</code></pre>
<p>最后，正则表达式是非常厉害的工具，通常可以用来解决字符串内置函数无法解决的问题，而且正则表达式大部分语言都是有的。python 的用途很多，但在爬虫和数据分析这连个模块中都是离不开正则表达式的。所以正则表达式对于学习 Python 来说，真的很重要。最后，附送一些常用的正则表达式和正则表达式和 Python 支持的正则表达式元字符和语法文档。</p>
<p>github：https://github.com/TwoWater/Python/blob/master/python14/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md</p>
<p>欢迎大家 start ，https://github.com/TwoWater/Python 一下，这是草根学 Python 系列博客的库。也可以关注我的微信公众号：</p>
<figure data-type="image" tabindex="1"><img src="http://twowater.com.cn/images/20171204192251900.gif" alt="http://twowater.com.cn/images/20171204192251900.gif" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[14-5]]></title>
        <id>https://dupl.github.io/gridea/post/14-5/</id>
        <link href="https://dupl.github.io/gridea/post/14-5/">
        </link>
        <updated>2025-02-20T12:50:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="resub">re.sub</h1>
<p>实战过程中，我们很多时候需要替换字符串中的字符，这时候就可以用到 <code>def sub(pattern, repl, string, count=0, flags=0)  </code> 函数了，re.sub 共有五个参数。其中三个必选参数：pattern, repl, string ; 两个可选参数：count, flags .</p>
<p>具体参数意义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>表示正则中的模式字符串</td>
</tr>
<tr>
<td>repl</td>
<td>repl，就是replacement，被替换的字符串的意思</td>
</tr>
<tr>
<td>string</td>
<td>即表示要被处理，要被替换的那个 string 字符串</td>
</tr>
<tr>
<td>count</td>
<td>对于pattern中匹配到的结果，count可以控制对前几个group进行替换</td>
</tr>
<tr>
<td>flags</td>
<td>正则表达式修饰符</td>
</tr>
</tbody>
</table>
<p>具体使用可以看下下面的这个实例，注释都写的很清楚的了，主要是注意一下，第二个参数是可以传递一个函数的，这也是这个方法的强大之处，例如例子里面的函数 <code>convert</code> ,对传递进来要替换的字符进行判断，替换成不同的字符。</p>
<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import re

a = 'Python*Android*Java-888'

# 把字符串中的 * 字符替换成 &amp; 字符
sub1 = re.sub('\*', '&amp;', a)
print(sub1)

# 把字符串中的第一个 * 字符替换成 &amp; 字符
sub2 = re.sub('\*', '&amp;', a, 1)
print(sub2)


# 把字符串中的 * 字符替换成 &amp; 字符,把字符 - 换成 |

# 1、先定义一个函数
def convert(value):
    group = value.group()
    if (group == '*'):
        return '&amp;'
    elif (group == '-'):
        return '|'


# 第二个参数，要替换的字符可以为一个函数
sub3 = re.sub('[\*-]', convert, a)
print(sub3)
</code></pre>
<p>输出的结果：</p>
<pre><code class="language-txt">Python&amp;Android&amp;Java-888
Python&amp;Android*Java-888
Python&amp;Android&amp;Java|888
</code></pre>
]]></content>
    </entry>
</feed>