<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>6-3 | Gridea</title>
<link rel="shortcut icon" href="https://dupl.github.io/gridea/favicon.ico?v=1744703986223">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dupl.github.io/gridea/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="6-3 | Gridea - Atom Feed" href="https://dupl.github.io/gridea/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="三、函数的参数
1、函数的参数类型
设置与传递参数是函数的重点，而 Python 的函数对参数的支持非常的灵活。
主要的参数类型有：默认参数、关键字参数（位置参数）、不定长参数。
下面我们将一一了解这几种参数。
2、默认参数
有时候，我们自..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dupl.github.io/gridea">
  <img class="avatar" src="https://dupl.github.io/gridea/images/avatar.png?v=1744703986223" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://dupl.github.io/gridea" class="menu">
          首页
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              6-3
            </h2>
            <div class="post-info">
              <span>
                2025-02-20
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://dupl.github.io/gridea/tag/uIwvvo8-6A_/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="三-函数的参数">三、函数的参数</h1>
<h2 id="1-函数的参数类型">1、函数的参数类型</h2>
<p>设置与传递参数是函数的重点，而 Python 的函数对参数的支持非常的灵活。</p>
<p>主要的参数类型有：默认参数、关键字参数（位置参数）、不定长参数。</p>
<p>下面我们将一一了解这几种参数。</p>
<h2 id="2-默认参数">2、默认参数</h2>
<p>有时候，我们自定义的函数中，如果调用的时候没有设置参数，需要给个默认值，这时候就需要用到默认值参数了。</p>
<p>默认参数，只要在构造函数参数的时候，给参数赋值就可以了</p>
<p>例如：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_user_info( name , age , sex = '男' ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex))
    return;

# 调用 print_user_info 函数

print_user_info( '两点水' , 18 , '女')
print_user_info( '三点水' , 25 )
</code></pre>
<p>输出结果：</p>
<pre><code class="language-txt">昵称：两点水 年龄：18 性别：女
昵称：三点水 年龄：25 性别：男
</code></pre>
<p>从输出结果可以看到，当你设置了默认参数的时候，在调用函数的时候，不传该参数，就会使用默认值。</p>
<p>但是这里需要注意的一点是：<strong>只有在形参表末尾的那些参数可以有默认参数值</strong>，也就是说你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。</p>
<p>这是因为赋给形参的值是根据位置而赋值的。例如，def func(a, b=1) 是有效的，但是 def func(a=1, b) 是 无效 的。</p>
<p>默认值参数就这样结束了吗？</p>
<p>还没有的，细想一下，如果参数中是一个可修改的容器比如一个 lsit （列表）或者 dict （字典），那么我们使用什么来作为默认值呢？</p>
<p>我们可以使用 None 作为默认值。就像下面这个例子一样：</p>
<pre><code class="language-python"># 如果 b 是一个 list ，可以使用 None 作为默认值
def print_info( a , b = None ):
    if b is None :
        b=[]
    return;
</code></pre>
<p>认真看下例子，会不会有这样的疑问呢？在参数中我们直接 <code>b=[]</code> 不就行了吗？</p>
<p>也就是写成下面这个样子：</p>
<pre><code class="language-python">def print_info( a , b = [] ):
    return;
</code></pre>
<p>对不对呢？</p>
<p>运行一下也没发现错误啊，可以这样写吗？</p>
<p>这里需要特别注意的一点：<strong>默认参数的值是不可变的对象，比如None、True、False、数字或字符串</strong>，如果你像上面的那样操作，当默认值在其他地方被修改后你将会遇到各种麻烦。</p>
<p>这些修改会影响到下次调用这个函数时的默认值。</p>
<p>示例如下：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_info( a , b = [] ):
    print(b)
    return b ;

result = print_info(1)

result.append('error')

print_info(2)
</code></pre>
<p>输出的结果：</p>
<pre><code class="language-txt">[]
['error']
</code></pre>
<p>认真观察，你会发现第二次输出的值根本不是你想要的，因此切忌不能这样操作。</p>
<p>还有一点，有时候我就是不想要默认值啊，只是想单单判断默认参数有没有值传递进来，那该怎么办？</p>
<p>我们可以这样做：</p>
<pre><code class="language-python">_no_value =object()

def print_info( a , b = _no_value ):
    if b is _no_value :
        print('b 没有赋值')
    return;
</code></pre>
<p>这里的 <code>object</code> 是 python 中所有类的基类。 你可以创建 <code>object</code> 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。也正好利用这个特性，来判断是否有值输入。</p>
<h2 id="3-关键字参数位置参数">3、关键字参数（位置参数）</h2>
<p>一般情况下，我们需要给函数传参的时候，是要按顺序来的，如果不对应顺序，就会传错值。</p>
<p>不过在 Python 中，可以通过参数名来给函数传递参数，而不用关心参数列表定义时的顺序，这被称之为关键字参数。</p>
<p>使用关键参数有两个优势 ：</p>
<ul>
<li>
<p>由于我们不必担心参数的顺序，使用函数变得更加简单了。</p>
</li>
<li>
<p>假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值</p>
</li>
</ul>
<p>具体看例子：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_user_info( name ,  age  , sex = '男' ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex))
    return;

# 调用 print_user_info 函数

print_user_info( name = '两点水' ,age = 18 , sex = '女')
print_user_info( name = '两点水' ,sex = '女', age = 18 )

</code></pre>
<p>输出的值：</p>
<pre><code class="language-txt">昵称：两点水 年龄：18 性别：女
昵称：两点水 年龄：18 性别：女
</code></pre>
<h2 id="4-不定长参数">4、不定长参数</h2>
<p>或许有些时候，我们在设计函数的时候，我们有时候无法确定传入的参数个数。</p>
<p>那么我们就可以使用不定长参数。</p>
<p>Python 提供了一种元组的方式来接受没有直接定义的参数。这种方式在参数前边加星号 <code>*</code> 。</p>
<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。</p>
<p>例如：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_user_info( name ,  age  , sex = '男' , * hobby):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( '两点水' ,18 , '女', '打篮球','打羽毛球','跑步')

</code></pre>
<p>输出的结果：</p>
<pre><code class="language-python">昵称：两点水 年龄：18 性别：女 爱好：('打篮球', '打羽毛球', '跑步')
</code></pre>
<p>通过输出的结果可以知道，<code>*hobby</code>是可变参数，且 hobby 其实就是一个 tuple （元祖）</p>
<p>可变长参数也支持关键字参数（位置参数），没有被定义的关键参数会被放到一个字典里。</p>
<p>这种方式即是在参数前边加 <code>**</code>,更改上面的示例如下：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_user_info( name ,  age  , sex = '男' , ** hobby ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( name = '两点水' , age = 18 , sex = '女', hobby = ('打篮球','打羽毛球','跑步'))

</code></pre>
<p>输出的结果：</p>
<pre><code class="language-txt">昵称：两点水 年龄：18 性别：女 爱好：{'hobby': ('打篮球', '打羽毛球', '跑步')}	
</code></pre>
<p>通过对比上面的例子和这个例子，可以知道，<code>*hobby</code>是可变参数，且 hobby其实就是一个 tuple （元祖），<code>**hobby</code>是关键字参数，且 hobby 就是一个 dict （字典）</p>
<h2 id="5-只接受关键字参数">5、只接受关键字参数</h2>
<p>关键字参数使用起来简单，不容易参数出错，那么有些时候，我们定义的函数希望某些参数强制使用关键字参数传递，这时候该怎么办呢？</p>
<p>将强制关键字参数放到某个<code>*</code>参数或者单个<code>*</code>后面就能达到这种效果,比如：</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-

def print_user_info( name , *, age  , sex = '男' ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex))
    return;

# 调用 print_user_info 函数
print_user_info( name = '两点水' ,age = 18 , sex = '女' )

# 这种写法会报错，因为 age ，sex 这两个参数强制使用关键字参数
#print_user_info( '两点水' , 18 , '女' )
print_user_info('两点水',age='22',sex='男')
</code></pre>
<p>通过例子可以看，如果 <code>age</code> , <code>sex</code> 不使用关键字参数是会报错的。</p>
<p>很多情况下，使用强制关键字参数会比使用位置参数表意更加清晰，程序也更加具有可读性。使用强制关键字参数也会比使用 <code>**kw</code> 参数更好且强制关键字参数在一些更高级场合同样也很有用。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%89-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">三、函数的参数</a>
<ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">1、函数的参数类型</a></li>
<li><a href="#2-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">2、默认参数</a></li>
<li><a href="#3-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">3、关键字参数（位置参数）</a></li>
<li><a href="#4-%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0">4、不定长参数</a></li>
<li><a href="#5-%E5%8F%AA%E6%8E%A5%E5%8F%97%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">5、只接受关键字参数</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dupl.github.io/gridea/post/6-2/">
              <h3 class="post-title">
                6-2
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '9b1b3d5e02fd883c8d79',
    clientSecret: '7cd8d96a9db672953daac4c7219bb6d618cdd6a8',
    repo: 'gridea',
    owner: 'dupl',
    admin: ['dupl'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dupl.github.io/gridea/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
