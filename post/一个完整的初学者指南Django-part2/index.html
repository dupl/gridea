<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>一个完整的初学者指南Django-part2 | Gridea</title>
<link rel="shortcut icon" href="https://dupl.github.io/gridea/favicon.ico?v=1744703986223">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dupl.github.io/gridea/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="一个完整的初学者指南Django-part2 | Gridea - Atom Feed" href="https://dupl.github.io/gridea/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
 
介绍
欢迎来到 Django 教程的第二部分！在上一课中，我们安装了项目所需要的一切软件，希望你们在学习这篇文章之前，安装了 Python 3.6，并且在虚拟环境中运行Django 1.11。因为，在本篇文章中，我们将继续在这个项目中..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dupl.github.io/gridea">
  <img class="avatar" src="https://dupl.github.io/gridea/images/avatar.png?v=1744703986223" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://dupl.github.io/gridea" class="menu">
          首页
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              一个完整的初学者指南Django-part2
            </h2>
            <div class="post-info">
              <span>
                2025-02-20
              </span>
              <span>
                34 min read
              </span>
              
                <a href="https://dupl.github.io/gridea/tag/uIwvvo8-6A_/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <figure data-type="image" tabindex="1"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/featured.jpg" alt="一个完整的初学者指南Django  - 第2部分" loading="lazy"></figure>
<p><img src="https://img.shields.io/badge/python-3.6.2-brightgreen.svg" alt="Python 3.6.2" loading="lazy"> <img src="https://img.shields.io/badge/django-1.11.4-brightgreen.svg" alt="Django 1.11.4" loading="lazy"></p>
<h4 id="介绍">介绍</h4>
<p>欢迎来到 Django 教程的第二部分！在上一课中，我们安装了项目所需要的一切软件，希望你们在学习这篇文章之前，安装了 Python 3.6，并且在虚拟环境中运行Django 1.11。因为，在本篇文章中，我们将继续在这个项目中编写我们的代码。</p>
<p>在这一篇文章中，可能不会有太多的代码操作，主要是讨论分析项目。在下一篇中，我们就开始学习 Django 的基础知识，包括模型（models），管理后台（admin），视图（views），模板（templates）和 路由（URL）。</p>
<p>在这里，还是跟第一篇一样，建议大家多动手。</p>
<hr>
<h4 id="论坛项目">论坛项目</h4>
<p>每个人的学习习惯都是不同的，不知道你们是怎样的，就我个人而言，通过看实例和一些代码片段，可以让我学的更多，学的更快。但是，有些时候当我们看到 <code>Class A</code>和<code>Class B</code> ，或者是 <code>foo(bar)</code> 这样的例子的时候，我们是很难理解这些概念的。</p>
<p>所以在我们进入模型（models），创建视图（views） 这些有趣的代码实操之前，我们还是需要花点时间，简单的讨论一下我们将怎样设计，开发这个项目。</p>
<p>但是如果你已经有 web 开发经验的，而且觉得讲的太细了，那么你可以快速的浏览一下，然后进入到 【模型（models）】那一块中。</p>
<p>如果你对 Web 开发并不熟悉，那么我强烈建议你认真阅读下去。这里会介绍 web 应用程序开发的建模和设计，因为对于 web 开发来说，敲代码只是其中的一部分，模型的设计也是很重要的。</p>
<figure data-type="image" tabindex="2"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Rocket_Science.png" alt="火箭科学" loading="lazy"></figure>
<h5 id="用例图">用例图</h5>
<p>我们的项目本身是一个论坛系统，整个项目来说就是维护几个【论坛板块（boards）】 ，然后在每个板块里面，用户可以通过创建【主题（Topic）】并且在主题中讨论。</p>
<p>一般情况下，只有管理员才能创建【论坛板块（boards）】，那么在用户这方面，我们就需要分为普通用户和管理员用户了，而且他们拥有的权限是不同的，管理员用户可以创建 【论坛板块（boards）】，【主题（Topic）】以及讨论回复，而普通用户只能发布【主题（Topic）】以及讨论回复。具体每个用户角色的功能分配如下图：</p>
<blockquote>
<p>图1：Web Board 核心功能的用例图</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/use-case-diagram.png" alt="用例图" loading="lazy"></figure>
<h5 id="类图">类图</h5>
<p>从上面的用例图中，我们可以开始思考我们项目中的<strong>实体类</strong>有哪些了。这些实体是我们要创建的模型，它与我们的 Django 应用非常密切。</p>
<p>如果要实现上面我们说到的论坛，那么我们至少需要以下的几个模型：<strong>Board</strong>，<strong>Topic</strong>，<strong>Post</strong>和<strong>User</strong>。</p>
<ul>
<li><strong>Board</strong> : 版块</li>
<li><strong>Topic</strong> : 主题</li>
<li><strong>Post</strong> : 帖子（用户评论与回复）</li>
<li><strong>User</strong> : 用户</li>
</ul>
<blockquote>
<p>图2：Web Board 类图</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/basic-class-diagram.png" alt="基本类图" loading="lazy"></figure>
<p>上面我们只是说了需要有几个模型，并没有提到模型与模型之间是怎么关联的。</p>
<p>通过上面的图片我们可以知道，主题（Topic）与版块（Board） 之间是有关联的，就好比我们需要知道这个主题（Topic） 是属于哪一个版块的（Board），因此我们需要一个字段，也就是可以通过外键爱关联它们。</p>
<p>同样的，一个帖子（Post） 也是需要确定它是那个主题的，当然，用户和主题（Topic）和帖子（Post） 之间也是有联系的，因为我们需要确认是谁发的帖子，是谁回复评论了内容。</p>
<p>竟然知道了模型之间的联系了，那么我们也必须要考虑这些模型应该存放哪些信息。就目前而言，我们的模型可以设计成这样：</p>
<blockquote>
<p>图3：类（模型）之间关系的类图</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram.png" alt="类图" loading="lazy"></figure>
<p>这个类图强调的是模型之间的关系，当然最后这些线条和箭头都会用字段来进行表示。</p>
<p><strong>Board（版块模型）</strong> ：Board 中有 <strong>name</strong> 和 <strong>description</strong> 这两个字段，name 是唯一的，主要是为了避免两个名称重复。description 则是用于描述把这个版块来用干什么的。</p>
<p><strong>Topic（主题模型）</strong> ：subject 表示主题内容，last_update 用来定义话题的排序，starter 用来识别谁发起的话题，board 用于指定它属于哪个版块</p>
<p><strong>Post（帖子模型）</strong> ： message 字段，用于存储回复的内容，created_at 创建的时间，在排序时候用（最先发表的帖子排最前面），updated_at 更新时间，告诉用户是否更新了内容，同时，还需要有对应的 User 模型的引用，Post 由谁创建的和谁更新的。</p>
<p><strong>User（用户模型）</strong> ：这里有 username ，password，email 和 is_superuser 四个字段。</p>
<p>这里值得注意的是，我们在 Django 应用中，不需要创建 User 用户模型，因为在 Django 的 contrib 中已经内置了 User 模型，我们可以直接拿来使用，就没必要重新创建了。</p>
<p>认真观察的童鞋应该看到了，上面的模型关系图中，模型与模型之间的对应关系有数字 1，0..* 等等的字段，这是代表什么意思呢？</p>
<p>如下图，<code>1</code> 代表一个 Topic 必须与一个  Board 相关联，<code>0..*</code> 代表 Board 下面可能会有多个和 0 个 Topic ，也就是一对多的关系。</p>
<figure data-type="image" tabindex="6"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-board-topic.png" alt="类图板和主题协会" loading="lazy"></figure>
<p>这里也是一样，<code>1</code> 代表一个 Post 只有一个  Topic ，<code>1..*</code> 代表一个 Topic 下面可能会有 1 个和多个个 Post ，也就是说，一个主题最少一个一个帖子。</p>
<figure data-type="image" tabindex="7"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-post.png" alt="类图主题和帖子关联" loading="lazy"></figure>
<p><code>1</code> 代表一个 Topic 有且至于一个  User ，<code>0..*</code> 代表一个 User（用户） 可能拥有多个 Topic ，也可能没有。</p>
<figure data-type="image" tabindex="8"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-topic-user.png" alt="类图主题和用户关联" loading="lazy"></figure>
<p>Post（帖子） 和 User（用户）的关系也是类似，一个 Post 必须有一个 User ，而一个 User 可能没有也可能有多个 Post。这里的 Post ，用户发布了之后是可以进行修改的，也就是更新（updated_by），当然如果又被修改，updated_by 就是为空了。</p>
<p><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-post-user.png" alt="类图邮政和用户协会" loading="lazy">一</p>
<p>当然，如果你觉得上面的图看起来很复杂，那么你也可以不需要强调模型与模型之间的关系，直接强调字段就可以了，如下图：</p>
<blockquote>
<p>图4：强调类（模型）属性（字段）的类图</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-attributes.png" alt="类图属性" loading="lazy"></figure>
<p>其实这种表达图和前面那个显示箭头和线的表达图，要表达的内容是一样的。不过使用这种表达方式可能更符合 Django  Modles API 的设计。</p>
<p>好了，现在已经够 UML 了！为了绘制本节介绍的图表，我使用的是 <a href="http://staruml.io/">StarUML</a> 工具。</p>
<h5 id="原型图">原型图</h5>
<p>花了一些时间来设计我们的程序模型，后面我们也需要设计一下我们的网页原型图。只有这样，才能更好的让我们清楚的知道自己将要干什么？</p>
<figure data-type="image" tabindex="10"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Wireframes.png" alt="线框漫画" loading="lazy"></figure>
<p>首先，是我们的主页，在主页中，我们会显示我们所有的版块：</p>
<blockquote>
<p>图5：主页显示所有的版块信息</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-boards.png" alt="线框板" loading="lazy"></figure>
<p>同样的，当用户点进了版块信息，进入到版块页面，那么版块页面也将显示该版块下的所有主题：</p>
<blockquote>
<p>图6：版块下的所有主题信息</p>
</blockquote>
<figure data-type="image" tabindex="12"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-topics.png" alt="线框主题" loading="lazy"></figure>
<p>通过观察图片，细心的你，可能会发现，用户在这个页面有两条可以走的路线。第一条就是点击 “new topic” 来创建新的主题，第二条就是点击已经存在的主题进入相关的主题进行讨论回复。</p>
<p>“new topic” 的界面如下 ：</p>
<figure data-type="image" tabindex="13"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-new-topic.png" alt="线框新主题" loading="lazy"></figure>
<p>而，进入了相关的主题后，应该显示具体的帖子信息和用户的一些回复信息：</p>
<figure data-type="image" tabindex="14"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-posts.png" alt="线框帖子" loading="lazy"></figure>
<p>如果用户点击 “Reply” 的按钮，他们将看到下面的页面，并以相反的顺序（最新的第一个）对帖子进行显示：</p>
<figure data-type="image" tabindex="15"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/wireframe-reply.png" alt="线框回复" loading="lazy"></figure>
<p>那么这些图是用什么来绘制的呢？你可以使用 <a href="https://draw.io/">draw.io</a> ，而且他是完全免费的。</p>
<hr>
<h4 id="模型models">模型（Models）</h4>
<p>上一部分，设计了我们 Web 应用的数据库还有界面原型设计。在模型（Models）这一部分中，我们将在 Django 中创建我们数据库的模型类：<strong>Board</strong> ，<strong>Topic</strong> 和 <strong>Post</strong> 。</p>
<p>这里是不是有个疑问，明明我们设计数据库的时候是有 <strong>User</strong> 的，为什么我们不用创建它的模型类呢？是不是写漏了？</p>
<p>并不是，那是因为 <strong>User</strong> 这个模型类，已经内置在 Django 应用程序中的，<strong>User</strong> 模型就在 <strong>django.contrib.auth</strong> 中。在 settings.py 中，<code>INSTALLED_APPS</code> 就配置了<strong>django.contrib.auth</strong>。</p>
<p>好了，现在我们将根据我们上面设计的数据库模型来完成我们项目 <strong>boards</strong> 下的 models.py 文件中的所有操作。</p>
<blockquote>
<p><strong>boards/models.py</strong></p>
</blockquote>
<pre><code class="language-python">from django.db import models
from django.contrib.auth.models import User

class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

class Topic(models.Model):
    subject = models.CharField(max_length=255)
    last_updated = models.DateTimeField(auto_now_add=True)
    board = models.ForeignKey(Board, related_name='topics')
    starter = models.ForeignKey(User, related_name='topics')

class Post(models.Model):
    message = models.TextField(max_length=4000)
    topic = models.ForeignKey(Topic, related_name='posts')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    created_by = models.ForeignKey(User, related_name='posts')
    updated_by = models.ForeignKey(User, null=True, related_name='+')
</code></pre>
<p>可以看到，创建的所有模型类，<strong>Board</strong> ， <strong>Topic</strong> 和 <strong>Post</strong> 都是 <strong>django.db.models.Model</strong> 的子类，它们都将会转化成数据表。而 <strong>django.db.models.Field</strong> 的子类（Django 内置的核心类）的实例都会转化为数据表中的列。</p>
<p>上面可以看到的 <code>CharField</code>，<code>DateTimeField</code> 等，都是 <strong>django.db.models.Field</strong> 的子类，在 Django 项目中都可以直接使用它们。</p>
<p>在这里，我们仅仅使用了 <code>CharField</code>，<code>TextField</code>，<code>DateTimeField</code>，和 <code>ForeignKey</code> 字段来定义我们的模型（Models） 。当然，在 Django 中，不仅仅只是提供了这些字段，还提供了更多，更广泛的选择来代表不同类型的数据，比如还有：<code>IntegerField</code>，<code>BooleanField</code>， <code>DecimalField</code>。我们会根据不同的需求来使用它们。</p>
<p>有些字段是需要参数的，就好比 <code>CharField</code> ，我们都设定了一个 <code>max_length</code> , 设置一个最大长度。当我们设定了这个字段后，就会作用于数据的。</p>
<p>在 <code>Board</code> 模型（Model）中，在 <code>name</code> 字段中，我们也设置了参数 <code>unique=True</code>，顾名思义，这是为了在数据库中，保证该字段的唯一性。</p>
<p>在 <code>Post</code> 模型中，<code>created_at</code> 字段有一个可选参数，<code>auto_now_add</code> 设置为 <code>True</code>。这是为了指明 Django 在创建 <code>Post</code> 对象的时候，<code>created_at</code> 使用的是当前的日期和时间。</p>
<p>创建模型与模型之间关系的其中一种方法就是使用 <code>ForeignKey</code> 字段，使用这个字段，会自动创建模型与模型之间的联系，而且会在数据库中也创建它们的关系。使用 <code>ForeignKey</code> 会有一个参数，来表明他与那个模型之间的联系。 例如：</p>
<p>在 <code>Topic</code> 模型中，<code>models.ForeignKey(Board, related_name='topics')</code>，第一个参数是代表关联的表格（主表），在默认情况下，外键存储的是主表的主键（Primary Key）。第二个参数 <code>related_name</code> 是定义一个名称，用于反向查询的。Django 会自动创建这种反向关系。 虽然 <code>related_name</code> 是可选参数，但是如果我们不为它设置一个名称的，Django 会默认生成名称 <code>(class_name)_set</code> 。例如，在 <code>Board</code> 模型中，<code>Topic</code> 实例将在该 <code>topic_set</code> 属性下可用。而我们只是将其重新命名为<code>topics</code>，使用起来更加自然。</p>
<p>在 <code>Post</code> 模型中，<code>updated_by</code> 字段设置<code>related_name='+'</code>。这指示 Django 我们不需要这种反向关系。</p>
<p>下面这张图可以很好地看到设计图和源码之间的比较，其中绿线就表示了我们是如何处理反向关系的。</p>
<figure data-type="image" tabindex="16"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/class-diagram-django-models.png" alt="类图模型定义" loading="lazy"></figure>
<p>可能到这一步，你会问：“主键呢？”好像我们都没有定义主键啊。对，如果我们没有为模型（Models）指定主键，那么 Django 会自动生成它。</p>
<h5 id="迁移模型migrating-the-models">迁移模型（Migrating the Models）</h5>
<p>到这一步，我们要开始告诉 Django 如何创建数据库，这样方便我们更好的使用。</p>
<p>打开<strong>终端</strong> ，激活虚拟环境，进入到 <strong>manage.py</strong> 文件所在的文件夹，然后运行以下命令：</p>
<pre><code>python manage.py makemigrations
</code></pre>
<p>这时，你会看到这样的输出信息：</p>
<pre><code>Migrations for 'boards':
  boards/migrations/0001_initial.py
    - Create model Board
    - Create model Post
    - Create model Topic
    - Add field topic to post
    - Add field updated_by to post
</code></pre>
<p><br>
此时，Django 在 <strong>boards / migrations</strong> 目录内创建了一个名为<strong>0001_initial.py</strong> 的文件。它代表了我们应用程序模型的当前状态。在下一步中，Django 将使用该文件来创建表和列。</p>
<p>迁移文件被翻译成 SQL 语句。如果您熟悉 SQL，则可以运行以下命令来检查将在数据库中执行的 SQL 指令：</p>
<pre><code>python manage.py sqlmigrate boards 0001
</code></pre>
<p>如果你不熟悉 SQL，也不用担心。在本系列教程中，我们不会直接使用 SQL。所有的工作都将使用 Django ORM 来完成，它是一个与数据库进行通信的抽象层。</p>
<p>好了，下一步我们将把我们的迁移文件应用到我们的数据库中：</p>
<pre><code>python manage.py migrate&lt;/code&gt;
</code></pre>
<p>输出应该是这样的：</p>
<pre><code>Operations to perform:
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
</code></pre>
<p>因为这是我们第一次迁移数据库，所以该 <code>migrate</code> 命令还应用了 Django contrib 应用中现有的迁移文件，这些文件列于 <code>settings.py</code> 中的 <code>INSTALLED_APPS</code> 。</p>
<p>而 <code>Applying boards.0001_initial... OK</code> 就是指我们在上一步中生成的迁移文件。</p>
<p>好了，此时！我们的数据库已经可以使用了。</p>
<figure data-type="image" tabindex="17"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_SQLite.png" alt="SQLite的" loading="lazy"></figure>
<blockquote>
<p><strong>注意：</strong> 需要注意的是 <strong>SQLite</strong> 是一个数据库。SQLite 被许多公司用于成千上万的产品，如所有 Android 和 iOS 设备，所有主要的 Web 浏览器，Windows 10，MacOS 等。</p>
<p>当然，它也不是适合所有的应用场景。SQLite 不能与 MySQL，PostgreSQL 或 Oracle 等数据库进行比较。大容量网站，密集型的应用程序，大数据集，高并发性，这些使用使用 SQLite 可能会导致很多问题。</p>
<p>在我们开发的项目中，我们将使用 SQLite ，因为它很方便，我们不需要安装其他任何东西。当我们将项目部署到生产环境时，我们将切换到 PostgreSQL 。因为这对于简单的网站是不错的选择。但这里有一点要注意，对于复杂的网站，建议在开发和生产中使用相同的数据库。</p>
</blockquote>
<h5 id="models-api">Models API</h5>
<p>使用 Python 开发的一个重要优点是交互式 shell。我几乎一直都在使用它。这是一个可以快速尝试和测试实验的方法。</p>
<p>你可以使用 <strong>manage.py</strong> 加载我们的项目来启动 Python shell ：</p>
<p>启动命令：</p>
<pre><code>python manage.py shell
</code></pre>
<p>可以看到这样的输出：</p>
<pre><code>Python 3.6.2 (default, Jul 17 2017, 16:44:45)
[GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
(InteractiveConsole)
&gt;&gt;&gt;
</code></pre>
<p>在我们使用 <code>python manage.py shell</code> 之外，我们也可以将项目添加到<code>sys.path</code>并加载 Django。这意味着我们可以在项目中导入我们的模型(models) 和任何其他资源。</p>
<p>我们从导入 <strong>Board</strong> 类开始：</p>
<pre><code>from boards.models import Board
</code></pre>
<p>如果我们需要创建 <strong>Board</strong> 对象，我们可以执行以下操作：</p>
<pre><code>board = Board(name='Django', description='This is a board about Django.')
</code></pre>
<p>此时我们只是创建了这个对象，并没有保存到数据库的，因此我们可以调用 <code>save</code> 方法，将这个对象保存在数据库中。</p>
<pre><code>board.save()
</code></pre>
<p>该 <code>save</code> 方法 ，在创建对象和更新对象中都可以使用，这里 Django 会创建一个新的对象，因为 <strong>Board</strong> 实例是没有 <strong>id</strong> 这个字段的，因此保存后，Django 会自动设置一个 ID ：</p>
<pre><code>board.id
1
</code></pre>
<p>其他的字段你也可以当作属性来访问就好了，比如：</p>
<pre><code>board.name
'Django'
</code></pre>
<pre><code>board.description
'This is a board about Django.'
</code></pre>
<p>要更新一个值，我们可以这样做：</p>
<pre><code>board.description = 'Django discussion board.'
board.save()
</code></pre>
<p>每个 Django 模型 (Models) 都带有一个特殊的属性; 我们称之为 <strong>Model Manager（模型管理器）</strong>。我们可以通过 Python 属性 <code>objects</code> 来访问它。它主要用于在数据库中执行查询。例如，我们可以使用它来直接创建一个新的<strong>Board</strong> 对象：</p>
<pre><code>board = Board.objects.create(name='Python', description='General discussion about Python.')
</code></pre>
<pre><code>board.id
2
</code></pre>
<pre><code>board.name
'Python'
</code></pre>
<p>所以，结合之前的操作，我们现在有两个 boards 对象。我们可以使用<code>objects</code> 列出数据库中所有现有的 boards ：</p>
<pre><code>Board.objects.all()
&lt;QuerySet [&lt;Board: Board object&gt;, &lt;Board: Board object&gt;]&gt;
</code></pre>
<p>结果是一个 <strong>QuerySet</strong> 。稍后我们会进一步了解它。基本上，它是来自数据库的对象列表。通过输出结果，可以看到我们有两个对象，但我们只能读取 <strong>Board对象</strong> 。这是因为我们没有在 <strong>Board</strong> 模型中定义 <code>__str__</code> 方法。</p>
<p>该 <code>__str__</code> 方法是一个对象的字符串表示。我们可以使用 Board 的名称来表示它。</p>
<p>首先，退出交互式控制台：</p>
<pre><code>exit()
</code></pre>
<p>现在编辑 <strong>boards</strong> 应用程序中的 <strong>models.py</strong> 文件：</p>
<pre><code>class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)

    def __str__(self):
        return self.name
</code></pre>
<p>让我们再次尝试查询。再次打开交互式控制台：</p>
<pre><code>from boards.models import Board

Board.objects.all()
&lt;QuerySet [&lt;Board: Django&gt;, &lt;Board: Python&gt;]&gt;
</code></pre>
<p>仔细对比上面的，看下区别？</p>
<p>可以看到上面那个是 object ，而这里是我们定义的字符串。</p>
<p>我们可以将这个 <strong>QuerySet</strong> 看作一个列表。假设我们想遍历它并打印每个 Board（版块） 的描述：</p>
<pre><code>boards_list = Board.objects.all()
for board in boards_list:
    print(board.description)
</code></pre>
<p>结果是：</p>
<pre><code>Django discussion board.
General discussion about Python.
</code></pre>
<p>当然，我们也可以使用 <strong>Model Manager（模型管理器）</strong> 来查询数据库，如果查询其中的一个，我们可以使用 <code>get</code> 的方法：</p>
<pre><code>django_board = Board.objects.get(id=1)

django_board.name
'Django'
</code></pre>
<p>当然我们要小心这种情况，因为很容易发生内存溢出的。比如我们试图去查询一个不存在的对象，就好比我们数据库只有两个 Board 对象，如果你查询 <code>id=3</code>，那么它会引发一个异常：</p>
<pre><code>board = Board.objects.get(id=3)

boards.models.DoesNotExist: Board matching query does not exist.
</code></pre>
<p>当然，在 <code>get</code> 方法中，参数可以是该模型下的字段，最好是使用唯一的标识字段。否则会返回多个对象，会导致异常的。</p>
<pre><code>Board.objects.get(name='Django')
&lt;Board: Django&gt;
</code></pre>
<p>请注意，查询是区分大小写的，小写 “django” 是不匹配的：</p>
<pre><code>Board.objects.get(name='django')
boards.models.DoesNotExist: Board matching query does not exist.
</code></pre>
<h5 id="模型操作摘要">模型操作摘要</h5>
<p>下面的表格是我们在本章节中学到的方法和操作。代码示例使用 <strong>Board</strong> 模型作为参考示例。大写的 <strong>Board</strong> 代表类，小写的 <strong>board</strong> 是指 <strong>Board</strong> 的实例对象。</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>代码示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建一个对象并没有保存</td>
<td><code>board = Board()</code></td>
</tr>
<tr>
<td>保存一个对象（创建或更新）</td>
<td><code>board.save()</code></td>
</tr>
<tr>
<td>在数据库中创建并保存一个对象</td>
<td><code>Board.objects.create(name='...', description='...')</code></td>
</tr>
<tr>
<td>列出所有对象</td>
<td><code>Board.objects.all()</code></td>
</tr>
<tr>
<td>获取由字段标识的单个对象</td>
<td><code>Board.objects.get(id=1)</code></td>
</tr>
</tbody>
</table>
<p>在下一节中，我们将开始编写视图并在 HTML 页面中显示我们的版块页面。</p>
<hr>
<h4 id="views-templates-和静态文件">Views, Templates 和静态文件</h4>
<p>回顾一下，我们之前做的。我们已经可以在应用程序的主页上显示 ”Hello ，World！“ 的界面了。</p>
<blockquote>
<p><strong>MyProject/urls.py</strong></p>
</blockquote>
<pre><code>from django.conf.urls import url
from django.contrib import admin

from boards import views

urlpatterns = [
    url(r'^/code&gt;, views.home, name='home'),
    url(r'^admin/', admin.site.urls),
]
</code></pre>
<blockquote>
<p><strong>boards/views.py</strong></p>
</blockquote>
<pre><code>from django.http import HttpResponse

def home(request):
    return HttpResponse('Hello, World!')
</code></pre>
<p>好了，现在我们需要修改这个主页，如果你不记得我们的主页要做成什么样子，可以看看之前我们已经设计好的原型界面图。我们在主页上，要做的是在表格中显示一些版块的名单和其他的一些信息。</p>
<p>首先我们要做的是：导入 <strong>Board</strong> 模型，然后获取所有的存在的版块（boards）信息</p>
<blockquote>
<p><strong>boards/views.py</strong></p>
</blockquote>
<pre><code>from django.http import HttpResponse
from .models import Board

def home(request):
    boards = Board.objects.all()
    boards_names = list()

    for board in boards:
        boards_names.append(board.name)

    response_html = '&lt;br&gt;'.join(boards_names)

    return HttpResponse(response_html)
</code></pre>
<p>然后我们运行，就会看到这个简单的 HTML 页面：</p>
<figure data-type="image" tabindex="18"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-httpresponse.png" alt="主页HttpResponse" loading="lazy"></figure>
<p>但是，一般情况下，我们是不会通过这种方式去渲染 HTML ，在 <strong>views.py</strong> 中，我们只需要获取 <strong>boards</strong> 的集合，至于 HTML 渲染那部分的代码，我们应该在 Django 的 templates 目录下完成。</p>
<h5 id="django-模板引擎设置">Django 模板引擎设置</h5>
<p>竟然我们要将 <strong>views.py</strong> 里渲染 HTML 的代码分离，那么我们首先要在 <strong>baords</strong> 的同目录下，创建一个名为 <strong>templates</strong> 的文件夹。</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/   &lt;-- here!
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>在我们创建的 <strong>templates</strong> 文件夹中，我们创建一个名为 <strong>home.html</strong> 的 HTML 文件</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Boards&lt;/h1&gt;

    {% for board in boards %}
      {{ board.name }} &lt;br&gt;
    {% endfor %}

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>home.html</strong> 的文件内容如上面的一样，是一些原始的 HTML 标签代码和 Django 语言上的代码：<code>{% for ... in ... %}</code> ，<code>{{ variable }}</code>。上面的代码中展示了如何使用 for 循环遍历 list 对象。</p>
<p>到此，我们的 HTML 页面已经完成了，可是我们还没有告诉 Django 在哪里能找到我们应用中的 <code>templates</code> 文件夹里的 HTML。</p>
<p>首先，我们在 Django 中绑定一下我们的 <code>templates</code> ,打开我们 ** myproject** 项目中的 <strong>settings.py</strong> 文件，搜索 <code>TEMPLATES</code> 变量然后在 <code>DIRS</code>设置 ：<code>os.path.join(BASE_DIR, 'templates')</code></p>
<p>具体如下：</p>
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates')
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre>
<p>这样设计就好比相当于在你的项目中的完整路径下，在加上 &quot;/templates&quot;</p>
<p>那是不是跟我们预想的一样呢？我们可以通过 python shell 进行调试：</p>
<pre><code>python manage.py shell
</code></pre>
<pre><code>from django.conf import settings

settings.BASE_DIR
'/Users/vitorfs/Development/myproject'

import os

os.path.join(settings.BASE_DIR, 'templates')
'/Users/vitorfs/Development/myproject/templates'
</code></pre>
<p>可以看到，目录就是指向我们在上面创建的 <strong>templates</strong> 文件夹</p>
<p>此时，我们只是绑定了 <strong>templates</strong> 文件夹的路径，Django 并没有绑定我们 <strong>home.html</strong> ，我们可以在 <strong>views.py</strong> 中绑定：</p>
<pre><code>from django.shortcuts import render
from .models import Board

def home(request):
    boards = Board.objects.all()
    return render(request, 'home.html', {'boards': boards})
</code></pre>
<p>运行后，HTML 的页面是这样的：</p>
<figure data-type="image" tabindex="19"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render.png" alt="主板渲染" loading="lazy"></figure>
<p>我们可以改进HTML模板来代替使用表格：</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Boards&lt;/h1&gt;

    &lt;table border=&quot;1&quot;&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Board&lt;/th&gt;
          &lt;th&gt;Posts&lt;/th&gt;
          &lt;th&gt;Topics&lt;/th&gt;
          &lt;th&gt;Last Post&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {% for board in boards %}
          &lt;tr&gt;
            &lt;td&gt;
              {{ board.name }}&lt;br&gt;
              &lt;small style=&quot;color: #888&quot;&gt;{{ board.description }}&lt;/small&gt;
            &lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;0&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
          &lt;/tr&gt;
        {% endfor %}
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-render-2.png" alt="主板渲染" loading="lazy"></figure>
<h5 id="测试主页">测试主页</h5>
<figure data-type="image" tabindex="21"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Testing.png" alt="测试漫画" loading="lazy"></figure>
<p>测试这部分会在这系列教程中会不断的重复探讨。</p>
<p>现在让我们来写第一个测试，首先在应用程序 <strong>boards</strong> 中找到 <strong>tests.py</strong></p>
<blockquote>
<p><strong>boards/tests.py</strong></p>
</blockquote>
<pre><code>from django.core.urlresolvers import reverse
from django.test import TestCase

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
</code></pre>
<p>这是一个非常简单的测试用例，但非常的有用。我们在测试的是响应状态码，如果是 200 意味着成功。</p>
<p>我们可以在控制台中检查响应码：</p>
<figure data-type="image" tabindex="22"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/test-homepage-view-status-code-200.png" alt="回应200" loading="lazy"></figure>
<p>如果出现未捕获的异常，语法错误或其他任何情况，Django 会返回状态代码<strong>500</strong>，这意味着<strong>服务器错误</strong>。现在，想象我们的应用程序有 100 个界面（view）。如果我们为所有视图（view）编写了这个简单的测试，只需一个命令，我们就可以测试所有视图是否返回成功代码，这样用户就不会在任何地方看到任何错误消息。如果没有自动化测试，我们需要逐一检查每个页面。</p>
<p>要执行 Django 的测试套件：</p>
<pre><code>python manage.py test
</code></pre>
<pre><code>Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.041s

OK
Destroying test database for alias 'default'...
</code></pre>
<p>现在我们可以测试 Django 是否为请求的 URL 返回了正确的视图函数。这也是一个有用的测试，因为随着开发的进展，您会发现 <strong>urls.py</strong> 模块可能变得非常庞大而复杂。URL 配置全部是关于解析正则表达式的。有些情况下我们有一个非常宽容的URL，所以 Django 最终可能返回错误的视图函数。</p>
<p>以下是我们如何做到的：</p>
<blockquote>
<p><strong>boards/tests.py</strong></p>
</blockquote>
<pre><code>from django.core.urlresolvers import reverse
from django.urls import resolve
from django.test import TestCase
from .views import home

class HomeTests(TestCase):
    def test_home_view_status_code(self):
        url = reverse('home')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

    def test_home_url_resolves_home_view(self):
        view = resolve('/')
        self.assertEquals(view.func, home)
</code></pre>
<p>在第二个测试中，我们正在使用 <code>resolve</code> 功能。Django 使用它来将请求的 URL与 <strong>urls.py</strong> 模块中列出的 URL 列表进行匹配。该测试将确保使用 <code>/</code>根 URL ，是否返回主视图（home view）。</p>
<p>再次测试：</p>
<pre><code>python manage.py test
</code></pre>
<pre><code>Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.027s

OK
Destroying test database for alias 'default'...
</code></pre>
<p>要查看有关测试执行的更多详细信息，请将 <strong>verbosity</strong> 设置为更高级别：</p>
<pre><code>python manage.py test --verbosity=2
</code></pre>
<pre><code>Creating test database for alias 'default' ('file:memorydb_default?mode=memory&amp;cache=shared')...
Operations to perform:
  Synchronize unmigrated apps: messages, staticfiles
  Apply all migrations: admin, auth, boards, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying boards.0001_initial... OK
  Applying sessions.0001_initial... OK
System check identified no issues (0 silenced).
test_home_url_resolves_home_view (boards.tests.HomeTests) ... ok
test_home_view_status_code (boards.tests.HomeTests) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.017s

OK
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&amp;cache=shared')...
</code></pre>
<p>详细程度决定了将要打印到控制台的通知和调试信息量; 0 是无输出，1 是正常输出，2 是详细输出。</p>
<h5 id="静态文件设置">静态文件设置</h5>
<p>静态文件是指 CSS，JavaScript，字体，图像或者是我们用来组成用户界面的任何其他资源。</p>
<p>事实上，Django 不提供这些文件。但在开发过程中，我们又会用到，因此 Django 提供了一些功能来帮助我们管理静态文件。这些功能可在配置文件（settings.py）中 <code>INSTALLED_APPS</code> 里的 <strong>django.contrib.staticfiles</strong> 。</p>
<p>有了这么多的前端组件库，我们没有理由继续渲染基本的 HTML 。我们可以轻松地将Bootstrap 4 添加到我们的项目中。Bootstrap 是一个用 HTML，CSS 和JavaScript 开发的开源工具包。</p>
<p>在项目根目录中，除<strong>boards</strong>，<strong>templates</strong> 和 <strong>myproject</strong> 文件夹外，我们还需要创建一个名为 <strong>static</strong> 的文件夹，并在 <strong>static</strong> 文件夹内创建另一个名为 <strong>css</strong> 文件夹：</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/       &lt;-- here
 |    |    +-- css/     &lt;-- and here
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>到 <a href="https://getbootstrap.com/docs/4.0/getting-started/download/#compiled-css-and-js">getbootstrap.com</a> 下载最新版本：</p>
<figure data-type="image" tabindex="23"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/bootstrap-download.png" alt="Bootstrap下载" loading="lazy"></figure>
<p>下载 <strong>Compiled CSS and JS</strong> 的版本。</p>
<p>解压从 Bootstrap 网站下载的 <strong>bootstrap-4.0.0-beta-dist.zip</strong> 文件，将文件 <strong>css / bootstrap.min.css</strong> 复制到我们项目的css文件夹中：</p>
<pre><code>myproject/
 |-- myproject/
 |    |-- boards/
 |    |-- myproject/
 |    |-- templates/
 |    |-- static/
 |    |    +-- css/
 |    |         +-- bootstrap.min.css    &lt;-- here
 |    +-- manage.py
 +-- venv/
</code></pre>
<p>还是一样的问题，我们需要将 Django 中的 <strong>settings.py</strong> 里配置一下静态文件的目录。在 <code>STATIC_URL</code> 添加以下内容：</p>
<pre><code>STATIC_URL = '/static/'

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
</code></pre>
<p>这里可以回忆一下，<code>TEMPLATES</code> 配置目录的路径，操作是差不多的。</p>
<p>现在我们必须在模板中加载静态文件（Bootstrap CSS文件）：</p>
<blockquote>
<p><strong>templates/home.html</strong></p>
</blockquote>
<pre><code>{% load static %}&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/bootstrap.min.css' %}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- body suppressed for brevity ... --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>首先，我们在 html 的开头加载静态文件：<code>{% load static %}</code></p>
<p><code>{% static %}</code> 是用于告诉资源文件存在的路径，在这是，<code>{% static 'css/bootstrap.min.css' %}</code> 就会返回 <strong>/static/css/bootstrap.min.css</strong> ，相当于 <strong>http://127.0.0.1:8000/static/css/bootstrap.min.css</strong></p>
<p>这个 <code>{% static %}</code> 标签将会和 <strong>settings.py</strong> 的 <code>STATIC_URL</code> 组成最终的 URL。怎么理解这句话呢？</p>
<p>例如，我们在静态文件托管在 <strong>https://static.example.com/</strong> ，然后我们设置了这个属性：<code>STATIC_URL=https://static.example.com/</code>，然后 <code>{% static 'css/bootstrap.min.css' %}</code> 返回的是 ：<strong>https://static.example.com/css/bootstrap.min.css</strong>。</p>
<p>如果还不能理解，放心，你现在只需要了解和记住相关的过程就行了，后面正式开发上线的时候，会继续开展这部分的内容。</p>
<p>刷新页面 <strong>127.0.0.1:8000</strong> 我们可以看到它是这个样子的：</p>
<figure data-type="image" tabindex="24"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap.png" alt="Boards主页Bootstrap" loading="lazy"></figure>
<p>现在我们可以编辑模板，以利用Bootstrap CSS：</p>
<p>现在我们可以利用 Bootstrap CSS 来编辑我们的模板页面了：</p>
<pre><code>{% load static %}&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Boards&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/bootstrap.min.css' %}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;ol class=&quot;breadcrumb my-4&quot;&gt;
        &lt;li class=&quot;breadcrumb-item active&quot;&gt;Boards&lt;/li&gt;
      &lt;/ol&gt;
      &lt;table class=&quot;table&quot;&gt;
        &lt;thead class=&quot;thead-inverse&quot;&gt;
          &lt;tr&gt;
            &lt;th&gt;Board&lt;/th&gt;
            &lt;th&gt;Posts&lt;/th&gt;
            &lt;th&gt;Topics&lt;/th&gt;
            &lt;th&gt;Last Post&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {% for board in boards %}
            &lt;tr&gt;
              &lt;td&gt;
                {{ board.name }}
                &lt;small class=&quot;text-muted d-block&quot;&gt;{{ board.description }}&lt;/small&gt;
              &lt;/td&gt;
              &lt;td class=&quot;align-middle&quot;&gt;0&lt;/td&gt;
              &lt;td class=&quot;align-middle&quot;&gt;0&lt;/td&gt;
              &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
          {% endfor %}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>修改后变成这样子：</p>
<figure data-type="image" tabindex="25"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-2.png" alt="Boards主页Bootstrap" loading="lazy"></figure>
<p>到目前为止，我们使用交互式控制台（<code>python manage.py shell</code>）添加新的版块（board）。但是这样很不方便，因此我们需要一个更好的方式来做这个。在下一节中，我们将为网站管理员实施一个管理界面来管理它。</p>
<hr>
<h4 id="django-admin简介">Django Admin简介</h4>
<p>当我们开始一个新项目时，Django 在 <code>INSTALLED_APPS</code> 中已经配置了 <strong>Django Admin</strong> 。</p>
<figure data-type="image" tabindex="26"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/Pixton_Comic_Django_Admin.png" alt="Django Admin漫画" loading="lazy"></figure>
<p>Django Admin 的一个很好的用例就是，在博客中，它可以被作者用来编写和发布文章。另一个例子是电子商务网站，工作人员可以创建，编辑，删除产品。</p>
<p>目前，我们将配置 Django Admin 来维护我们的应用程序的版块模块。</p>
<p>我们首先创建一个管理员帐户：</p>
<pre><code>python manage.py createsuperuser
</code></pre>
<p>按照说明操作：</p>
<pre><code>Username (leave blank to use 'vitorfs'): admin
Email address: admin@example.com
Password:
Password (again):
Superuser created successfully.
</code></pre>
<p>现在在浏览器中打开 URL：<strong>http://127.0.0.1:8000/admin/</strong></p>
<figure data-type="image" tabindex="27"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-login.png" alt="Django管理员登录" loading="lazy"></figure>
<p>输入 <strong>用户名</strong> 和 <strong>密码</strong> ：</p>
<figure data-type="image" tabindex="28"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin.png" alt="Django Admin" loading="lazy"></figure>
<p>在这里，它已经配置了一些功能，我们也可以添加<strong>用户</strong>和<strong>组</strong>来管理权限。</p>
<p>那么我们如何在这个管理后台中管理版块（Board）里面的内容呢？</p>
<p>其实很简单，在 <strong>board</strong> 目录下，<strong>admin.py</strong> 中添加以下代码：</p>
<blockquote>
<p><strong>boards/admin.py</strong></p>
</blockquote>
<pre><code>from django.contrib import admin
from .models import Board

admin.site.register(Board)
</code></pre>
<p>保存以下，然后刷新网页：</p>
<figure data-type="image" tabindex="29"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards.png" alt="Django管理委员会" loading="lazy"></figure>
<p>点击 <strong>Boards</strong> 链接就能查看现有版块列表：</p>
<figure data-type="image" tabindex="30"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list.png" alt="Django管理委员会名单" loading="lazy"></figure>
<p>我们可以通过点击 <strong>Add Board</strong> 按钮添加一个新的版块：</p>
<figure data-type="image" tabindex="31"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-add.png" alt="Django管理委员会添加" loading="lazy"></figure>
<p>点击 <strong>SAVE</strong> 按钮：</p>
<figure data-type="image" tabindex="32"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/django-admin-boards-list-2.png" alt="Django管理委员会名单" loading="lazy"></figure>
<p>我们可以检查一切是否正常，打开 <strong>http://127.0.0.1:8000</strong> URL：</p>
<figure data-type="image" tabindex="33"><img src="https://simpleisbetterthancomplex.com/media/series/beginners-guide/1.11/part-2/boards-homepage-bootstrap-3.png" alt="董事会主页" loading="lazy"></figure>
<hr>
<h4 id="结论">结论</h4>
<p>在本教程中，我们探讨了许多新概念。我们为我们的项目定义了一些要求，创建了第一个模型，迁移了数据库，开始玩 Models API。我们创建了第一个视图并编写了一些单元测试。我们还配置了 Django 模板引擎，静态文件，并将 Bootstrap 4 库添加到项目中。最后，我们简要介绍了 Django Admin 界面。</p>
<p>该项目的源代码在 GitHub 上,你可以在下面的链接中找到本章节的代码：</p>
<p><a href="https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw">https://github.com/sibtc/django-beginners-guide/tree/v0.2-lw</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE">论坛项目</a>
<ul>
<li><a href="#%E7%94%A8%E4%BE%8B%E5%9B%BE">用例图</a></li>
<li><a href="#%E7%B1%BB%E5%9B%BE">类图</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E5%9B%BE">原型图</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9E%8Bmodels">模型（Models）</a>
<ul>
<li><a href="#%E8%BF%81%E7%A7%BB%E6%A8%A1%E5%9E%8Bmigrating-the-models">迁移模型（Migrating the Models）</a></li>
<li><a href="#models-api">Models API</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C%E6%91%98%E8%A6%81">模型操作摘要</a></li>
</ul>
</li>
<li><a href="#views-templates-%E5%92%8C%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6">Views, Templates 和静态文件</a>
<ul>
<li><a href="#django-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E8%AE%BE%E7%BD%AE">Django 模板引擎设置</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%B8%BB%E9%A1%B5">测试主页</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE">静态文件设置</a></li>
</ul>
</li>
<li><a href="#django-admin%E7%AE%80%E4%BB%8B">Django Admin简介</a></li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dupl.github.io/gridea/post/一个完整的初学者指南Django-part1/">
              <h3 class="post-title">
                一个完整的初学者指南Django-part1
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '9b1b3d5e02fd883c8d79',
    clientSecret: '7cd8d96a9db672953daac4c7219bb6d618cdd6a8',
    repo: 'gridea',
    owner: 'dupl',
    admin: ['dupl'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dupl.github.io/gridea/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
