<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>tuple | Gridea</title>
<link rel="shortcut icon" href="https://dupl.github.io/gridea/favicon.ico?v=1744703986223">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dupl.github.io/gridea/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="tuple | Gridea - Atom Feed" href="https://dupl.github.io/gridea/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="二、tuple（元组）
1、什么是元组 （tuple）
上一节刚说了一个有序列表 List ，现在说另一种有序列表叫元组：tuple 。
tuple 和 List 非常类似，但是 tuple 一旦初始化就不能修改。
也就是说元组（tuple..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dupl.github.io/gridea">
  <img class="avatar" src="https://dupl.github.io/gridea/images/avatar.png?v=1744703986223" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="https://dupl.github.io/gridea" class="menu">
          首页
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dupl.github.io/gridea/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              tuple
            </h2>
            <div class="post-info">
              <span>
                2025-02-20
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://dupl.github.io/gridea/tag/uIwvvo8-6A_/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="二-tuple元组">二、tuple（元组）</h1>
<h2 id="1-什么是元组-tuple">1、什么是元组 （tuple）</h2>
<p>上一节刚说了一个有序列表 List ，现在说另一种有序列表叫元组：tuple 。</p>
<p>tuple 和 List 非常类似，但是 tuple 一旦初始化就不能修改。<br>
也就是说元组（tuple）是不可变的，那么不可变是指什么意思呢？</p>
<p>元组（tuple） 不可变是指当你创建了 tuple 时候，它就不能改变了，也就是说它也没有 append()，insert() 这样的方法，但它也有获取某个索引值的方法，但是不能赋值。</p>
<p>那么为什么要有 tuple 呢？</p>
<p>那是因为 tuple 是不可变的，所以代码更安全。</p>
<p>所以建议能用 tuple 代替 list 就尽量用 tuple 。</p>
<h2 id="2-怎样创建元组tuple">2、怎样创建元组（tuple）</h2>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<pre><code class="language-python">tuple1=('两点水','twowter','liangdianshui',123,456)
tuple2='两点水','twowter','liangdianshui',123,456
</code></pre>
<p>创建空元组</p>
<pre><code class="language-python">tuple3=()
</code></pre>
<p>元组中只包含一个元素时，需要在元素后面添加逗号</p>
<pre><code class="language-python">tuple4=(123,)
</code></pre>
<p>如果不加逗号，创建出来的就不是 元组（tuple），而是指 <code>123</code> 这个数了。</p>
<p>这是因为括号 () 既可以表示元组（tuple），又可以表示数学公式中的小括号，这就产生了歧义。</p>
<p>所以如果只有一个元素时，你不加逗号，计算机就根本没法识别你是要进行整数或者小数运算还是表示元组。</p>
<p>因此，Python 规定，这种情况下，按小括号进行计算，计算结果自然是 <code>123</code> ，而如果你要表示元组的时候，就需要加个逗号。</p>
<p>具体看下图 tuple4 和 tuple5 的输出值</p>
<figure data-type="image" tabindex="1"><img src="http://twowaterimage.oss-cn-beijing.aliyuncs.com/2019-08-31-093847.jpg" alt="" loading="lazy"></figure>
<h2 id="3-如何访问元组tuple">3、如何访问元组（tuple）</h2>
<p>元组下标索引也是从 0 开始，元组（tuple）可以使用下标索引来访问元组中的值。</p>
<pre><code class="language-python">#-*-coding:utf-8-*-

tuple1=('两点水','twowter','liangdianshui',123,456)
tuple2='两点水','twowter','liangdianshui',123,456

print(tuple1[1])
print(tuple2[0])
</code></pre>
<p>输出的结果：</p>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/2136918-edfb7c9ebc7d5ab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="访问 tuple" loading="lazy"></figure>
<h2 id="4-修改元组-tuple">4、修改元组 （tuple）</h2>
<p>可能看到这个小标题有人会疑问，上面不是花了一大段来说 tuple 是不可变的吗？</p>
<p>这里怎么又来修改 tuple （元组） 了。</p>
<p>那是因为元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，还有通过修改其他列表的值从而影响 tuple 的值。</p>
<p>具体看下面的这个例子：</p>
<pre><code class="language-python">#-*-coding:utf-8-*-
list1=[123,456]
tuple1=('两点水','twowater','liangdianshui',list1)
print(tuple1)
list1[0]=789
list1[1]=100
print(tuple1)
</code></pre>
<p>输出的结果：</p>
<pre><code>('两点水', 'twowater', 'liangdianshui', [123, 456])
('两点水', 'twowater', 'liangdianshui', [789, 100])
</code></pre>
<p>可以看到，两次输出的 tuple 值是变了的。我们看看 tuple1 的存储是怎样的。</p>
<figure data-type="image" tabindex="3"><img src="http://twowaterimage.oss-cn-beijing.aliyuncs.com/2019-08-31-%E4%BF%AE%E6%94%B9tuple%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="" loading="lazy"></figure>
<p>可以看到，tuple1 有四个元素，最后一个元素是一个 List ，List 列表里有两个元素。</p>
<p>当我们把 List 列表中的两个元素 <code>124</code> 和 <code>456</code> 修改为 <code>789</code> 和 <code>100</code> 的时候，从输出来的 tuple1 的值来看，好像确实是改变了。</p>
<p>但其实变的不是 tuple 的元素，而是 list 的元素。</p>
<p>tuple 一开始指向的 list 并没有改成别的 list，所以，tuple 所谓的“不变”是说，tuple 的每个元素，指向永远不变。注意是 tupe1 中的第四个元素还是指向原来的 list ，是没有变的，我们修改的只是列表 List 里面的元素。</p>
<h2 id="5-删除-tuple-元组">5、删除 tuple （元组）</h2>
<p>tuple 元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组</p>
<pre><code class="language-python">#-*-coding:utf-8-*-

tuple1=('两点水','twowter','liangdianshui',[123,456])
print(tuple1)
del tuple1
</code></pre>
<h2 id="6-tuple-元组运算符">6、tuple （元组）运算符</h2>
<p>与字符串一样，元组之间可以使用 <code>+</code> 号和 <code>*</code> 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len((1, 2, 3))</td>
<td>3</td>
<td>计算元素个数</td>
</tr>
<tr>
<td>(1, 2, 3) + (4, 5, 6)</td>
<td>(1, 2, 3, 4, 5, 6)</td>
<td>连接</td>
</tr>
<tr>
<td>('Hi!',) * 4</td>
<td>('Hi!', 'Hi!', 'Hi!', 'Hi!')</td>
<td>复制</td>
</tr>
<tr>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
</tr>
<tr>
<td>for x in (1, 2, 3):  print(x)</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<h2 id="7-元组内置函数">7、元组内置函数</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len(tuple)</td>
<td>计算元组元素个数</td>
</tr>
<tr>
<td>max(tuple)</td>
<td>返回元组中元素最大值</td>
</tr>
<tr>
<td>min(tuple)</td>
<td>返回元组中元素最小值</td>
</tr>
<tr>
<td>tuple(seq)</td>
<td>将列表转换为元组</td>
</tr>
</tbody>
</table>
<h2 id="8-实例">8、实例</h2>
<p>最后跟列表一样，来一个实例，大家也可以多尝试，去把元组的各种玩法玩一遍。</p>
<pre><code class="language-python">name1 = ('一点水', '两点水', '三点水', '四点水', '五点水')

name2 = ('1点水', '2点水', '3点水', '4点水', '5点水')

list1 = [1, 2, 3, 4, 5]

# 计算元素个数
print(len(name1))
# 连接,两个元组相加
print(name1 + name2)
# 复制元组
print(name1 * 2)
# 元素是否存在 (name1 这个元组中是否含有一点水这个元素)
print('一点水' in name1)
# 元素的最大值
print(max(name2))
# 元素的最小值
print(min(name2))
# 将列表转换为元组
print(tuple(list1))
</code></pre>
<p>输出的结果如下：</p>
<figure data-type="image" tabindex="4"><img src="http://twowaterimage.oss-cn-beijing.aliyuncs.com/2019-08-31-101523.png" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C-tuple%E5%85%83%E7%BB%84">二、tuple（元组）</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BB%84-tuple">1、什么是元组 （tuple）</a></li>
<li><a href="#2-%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84tuple">2、怎样创建元组（tuple）</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84tuple">3、如何访问元组（tuple）</a></li>
<li><a href="#4-%E4%BF%AE%E6%94%B9%E5%85%83%E7%BB%84-tuple">4、修改元组 （tuple）</a></li>
<li><a href="#5-%E5%88%A0%E9%99%A4-tuple-%E5%85%83%E7%BB%84">5、删除 tuple （元组）</a></li>
<li><a href="#6-tuple-%E5%85%83%E7%BB%84%E8%BF%90%E7%AE%97%E7%AC%A6">6、tuple （元组）运算符</a></li>
<li><a href="#7-%E5%85%83%E7%BB%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">7、元组内置函数</a></li>
<li><a href="#8-%E5%AE%9E%E4%BE%8B">8、实例</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dupl.github.io/gridea/post/List/">
              <h3 class="post-title">
                List
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '9b1b3d5e02fd883c8d79',
    clientSecret: '7cd8d96a9db672953daac4c7219bb6d618cdd6a8',
    repo: 'gridea',
    owner: 'dupl',
    admin: ['dupl'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dupl.github.io/gridea/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
